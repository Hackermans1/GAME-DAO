'use strict';

var lexical = require('lexical');
var cleanBasicHtml = require('@tryghost/kg-clean-basic-html');
var markdownHtmlRenderer = require('@tryghost/kg-markdown-html-renderer');

class KoenigDecoratorNode extends lexical.DecoratorNode {}

function $isKoenigCard(node) {
    return node instanceof KoenigDecoratorNode;
}

function buildCleanBasicHtmlForElement(domNode) {
    return function _cleanBasicHtml(html) {
        const cleanedHtml = cleanBasicHtml(html, {
            createDocument: (_html) => {
                const newDoc = domNode.ownerDocument.implementation.createHTMLDocument();
                newDoc.body.innerHTML = _html;
                return newDoc;
            }
        });
        return cleanedHtml;
    };
}

function readCaptionFromElement(element, {selector = 'figcaption'} = {}) {
    const cleanBasicHtml = buildCleanBasicHtmlForElement(element);

    let caption;

    const figcaptions = Array.from(element.querySelectorAll(selector));
    if (figcaptions.length) {
        figcaptions.forEach((figcaption) => {
            const cleanHtml = cleanBasicHtml(figcaption.innerHTML);
            caption = caption ? `${caption} / ${cleanHtml}` : cleanHtml;
        });
    }

    return caption;
}

function readImageAttributesFromElement(element) {
    const attrs = {};

    if (element.src) {
        attrs.src = element.src;
    }

    if (element.width) {
        attrs.width = element.width;
    } else if (element.dataset && element.dataset.width) {
        attrs.width = parseInt(element.dataset.width, 10);
    }

    if (element.height) {
        attrs.height = element.height;
    } else if (element.dataset && element.dataset.height) {
        attrs.height = parseInt(element.dataset.height, 10);
    }

    if ((!element.width && !element.height) && element.getAttribute('data-image-dimensions')) {
        const [, width, height] = (/^(\d*)x(\d*)$/gi).exec(element.getAttribute('data-image-dimensions'));
        attrs.width = parseInt(width, 10);
        attrs.height = parseInt(height, 10);
    }

    if (element.alt) {
        attrs.alt = element.alt;
    }

    if (element.title) {
        attrs.title = element.title;
    }

    if (element.parentNode.tagName === 'A') {
        const href = element.parentNode.href;

        if (href !== attrs.src) {
            attrs.href = href;
        }
    }

    return attrs;
}

class ImageParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            img: () => ({
                conversion(domNode) {
                    if (domNode.tagName === 'IMG') {
                        const {src, width, height, alt: altText, title} = readImageAttributesFromElement(domNode);

                        const node = new self.NodeClass({altText, src, title, width, height});
                        return {node};
                    }

                    return null;
                },
                priority: 1
            }),
            figure: (nodeElem) => {
                if (!nodeElem.querySelector('img')) {
                    return null;
                }
                return {
                    conversion(domNode) {
                        const img = domNode.querySelector('img');
                        const kgClass = domNode.className.match(/kg-width-(wide|full)/);
                        const grafClass = domNode.className.match(/graf--layout(FillWidth|OutsetCenter)/);

                        if (!img) {
                            return null;
                        }

                        const payload = readImageAttributesFromElement(img);

                        if (kgClass) {
                            payload.cardWidth = kgClass[1];
                        } else if (grafClass) {
                            payload.cardWidth = grafClass[1] === 'FillWidth' ? 'full' : 'wide';
                        }

                        payload.caption = readCaptionFromElement(domNode);

                        const {src, width, height, alt: altText, title, caption, cardWidth, href} = payload;
                        const node = new self.NodeClass({altText, src, title, width, height, caption, cardWidth, href});
                        return {node};
                    },
                    priority: 1
                };
            }
        };
    }
}

const getAvailableImageWidths = function (image, imageSizes) {
    // get a sorted list of the available responsive widths
    const imageWidths = Object.values(imageSizes)
        .map(({width}) => width)
        .sort((a, b) => a - b);

    // select responsive widths that are usable based on the image width
    const availableImageWidths = imageWidths
        .filter(width => width <= image.width);

    // add the original image size to the responsive list if it's not captured by largest responsive size
    // - we can't know the width/height of the original `src` image because we don't know if it was resized
    //   or not. Adding the original image to the responsive list ensures we're not showing smaller sized
    //   images than we need to be
    if (image.width > availableImageWidths[availableImageWidths.length - 1] && image.width < imageWidths[imageWidths.length - 1]) {
        availableImageWidths.push(image.width);
    }

    return availableImageWidths;
};

const isLocalContentImage = function (url, siteUrl = '') {
    const normalizedSiteUrl = siteUrl.replace(/\/$/, '');
    const imagePath = url.replace(normalizedSiteUrl, '');
    return /^(\/.*|__GHOST_URL__)\/?content\/images\//.test(imagePath);
};

const isUnsplashImage = function (url) {
    return /images\.unsplash\.com/.test(url);
};

// default content sizes: [600, 1000, 1600, 2400]

const getSrcsetAttribute = function ({src, width, options}) {
    if (!options.imageOptimization || options.imageOptimization.srcsets === false || !width || !options.imageOptimization.contentImageSizes) {
        return;
    }

    if (isLocalContentImage(src, options.siteUrl) && options.canTransformImage && !options.canTransformImage(src)) {
        return;
    }

    const srcsetWidths = getAvailableImageWidths({width}, options.imageOptimization.contentImageSizes);

    // apply srcset if this is a relative image that matches Ghost's image url structure
    if (isLocalContentImage(src, options.siteUrl)) {
        const [, imagesPath, filename] = src.match(/(.*\/content\/images)\/(.*)/);
        const srcs = [];

        srcsetWidths.forEach((srcsetWidth) => {
            if (srcsetWidth === width) {
                // use original image path if width matches exactly (avoids 302s from size->original)
                srcs.push(`${src} ${srcsetWidth}w`);
            } else if (srcsetWidth <= width) {
                // avoid creating srcset sizes larger than intrinsic image width
                srcs.push(`${imagesPath}/size/w${srcsetWidth}/${filename} ${srcsetWidth}w`);
            }
        });

        if (srcs.length) {
            return srcs.join(', ');
        }
    }

    // apply srcset if this is an Unsplash image
    if (isUnsplashImage(src)) {
        const unsplashUrl = new URL(src);
        const srcs = [];

        srcsetWidths.forEach((srcsetWidth) => {
            unsplashUrl.searchParams.set('w', srcsetWidth);
            srcs.push(`${unsplashUrl.href} ${srcsetWidth}w`);
        });

        return srcs.join(', ');
    }
};

const setSrcsetAttribute = function (elem, image, options) {
    if (!elem || !['IMG', 'SOURCE'].includes(elem.tagName) || !elem.getAttribute('src') || !image) {
        return;
    }

    const {src, width} = image;
    const srcset = getSrcsetAttribute({src, width, options});

    if (srcset) {
        elem.setAttribute('srcset', srcset);
    }
};

const resizeImage = function (image, {width: desiredWidth, height: desiredHeight} = {}) {
    const {width, height} = image;
    const ratio = width / height;

    if (desiredWidth) {
        const resizedHeight = Math.round(desiredWidth / ratio);

        return {
            width: desiredWidth,
            height: resizedHeight
        };
    }

    if (desiredHeight) {
        const resizedWidth = Math.round(desiredHeight * ratio);

        return {
            width: resizedWidth,
            height: desiredHeight
        };
    }
};

// If we're in a browser environment, we can use the global document object,
// but if we're in a non-browser environment, we need to be passed a `createDocument` function
function addCreateDocumentOption(options) {
    if (!options.createDocument) {
        /* c8 ignore start */
        let document = typeof window !== 'undefined' && window.document;

        if (!document) {
            throw new Error('renderImageNodeToDOM() must be passed a `createDocument` function as an option when used in a non-browser environment'); // eslint-disable-line
        }

        options.createDocument = function () {
            return document;
        };
        /* c8 ignore end */
    }
}

function renderImageNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    if (!node.getSrc() || node.getSrc().trim() === '') {
        return document.createTextNode('');
    }

    const figure = document.createElement('figure');

    let figureClasses = 'kg-card kg-image-card';
    if (node.getCardWidth() !== 'regular') {
        figureClasses += ` kg-width-${node.getCardWidth()}`;
    }

    figure.setAttribute('class', figureClasses);

    const img = document.createElement('img');
    img.setAttribute('src', node.getSrc());
    img.setAttribute('alt', node.getAltText());
    img.setAttribute('loading', 'lazy');

    if (node.getTitle()) {
        img.setAttribute('title', node.getTitle());
    }

    if (node.getImgWidth() && node.getImgHeight()) {
        img.setAttribute('width', node.getImgWidth());
        img.setAttribute('height', node.getImgHeight());
    }

    // images can be resized to max width, if that's the case output
    // the resized width/height attrs to ensure 3rd party gallery plugins
    // aren't affected by differing sizes
    const {canTransformImage} = options;
    const {defaultMaxWidth} = options.imageOptimization || {};
    if (
        defaultMaxWidth &&
            node.getImgWidth() > defaultMaxWidth &&
            isLocalContentImage(node.getSrc(), options.siteUrl) &&
            canTransformImage &&
            canTransformImage(node.getSrc())
    ) {
        const imageDimensions = {
            width: node.getImgWidth(),
            height: node.getImgHeight()
        };
        const {width, height} = resizeImage(imageDimensions, {width: defaultMaxWidth});
        img.setAttribute('width', width);
        img.setAttribute('height', height);
    }

    if (options.target !== 'email') {
        const imgAttributes = {
            src: node.getSrc(),
            width: node.getImgWidth(),
            height: node.getImgHeight()
        };
        setSrcsetAttribute(img, imgAttributes, options);

        if (img.getAttribute('srcset') && node.getImgWidth() && node.getImgWidth() >= 720) {
            // standard size
            if (!node.getCardWidth() || node.getCardWidth() === 'regular') {
                img.setAttribute('sizes', '(min-width: 720px) 720px');
            }

            if (node.getCardWidth() === 'wide' && node.getImgWidth() >= 1200) {
                img.setAttribute('sizes', '(min-width: 1200px) 1200px');
            }
        }
    }

    // Outlook is unable to properly resize images without a width/height
    // so we add that at the expected size in emails (600px) and use a higher
    // resolution image to keep images looking good on retina screens
    if (options.target === 'email' && node.getImgWidth() && node.getImgHeight()) {
        let imageDimensions = {
            width: node.getImgWidth(),
            height: node.getImgHeight()
        };
        if (node.getImgWidth() >= 600) {
            imageDimensions = resizeImage(imageDimensions, {width: 600});
        }
        img.setAttribute('width', imageDimensions.width);
        img.setAttribute('height', imageDimensions.height);

        if (isLocalContentImage(node.getSrc(), options.siteUrl) && options.canTransformImage?.(node.getSrc())) {
            // find available image size next up from 2x600 so we can use it for the "retina" src
            const availableImageWidths = getAvailableImageWidths(node, options.imageOptimization.contentImageSizes);
            const srcWidth = availableImageWidths.find(width => width >= 1200);

            if (!srcWidth || srcWidth === node.getImgWidth()) ; else {
                const [, imagesPath, filename] = node.getSrc().match(/(.*\/content\/images)\/(.*)/);
                img.setAttribute('src', `${imagesPath}/size/w${srcWidth}/${filename}`);
            }
        }
    }

    if (node.getHref()) {
        const a = document.createElement('a');
        a.setAttribute('href', node.getHref());
        a.appendChild(img);
        figure.appendChild(a);
    } else {
        figure.appendChild(img);
    }

    if (node.getCaption()) {
        const caption = document.createElement('figcaption');
        caption.innerHTML = node.getCaption();
        figure.appendChild(caption);
    }

    return figure;
}

const INSERT_IMAGE_COMMAND = lexical.createCommand();
const UPLOAD_IMAGE_COMMAND = lexical.createCommand();

class ImageNode extends KoenigDecoratorNode {
    // payload properties
    __src;
    __caption;
    __title;
    __altText;
    __cardWidth;
    __width;
    __height;
    __href;

    static getType() {
        return 'image';
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {
            src: 'url',
            href: 'url',
            caption: 'html'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            src: self.__src,
            caption: self.__caption,
            title: self.__title,
            altText: self.__altText,
            width: self.__width,
            height: self.__height,
            cardWidth: self.__cardWidth,
            href: self.__href
        };
    }

    constructor({src, caption, title, altText, cardWidth, width, height, href} = {}, key) {
        super(key);
        this.__src = src || '';
        this.__title = title || '';
        this.__caption = caption || '';
        this.__altText = altText || '';
        this.__width = width || null;
        this.__height = height || null;
        this.__cardWidth = cardWidth || 'regular';
        this.__href = href || '';
    }

    static importJSON(serializedNode) {
        const {src, caption, title, altText, width, height, cardWidth, href} = serializedNode;
        const node = new this({
            src,
            caption,
            title,
            altText,
            width,
            height,
            href,
            cardWidth
        });
        return node;
    }

    exportJSON() {
        // checks if src is a data string
        const src = this.getSrc();
        const isBlob = src.startsWith('data:');
        const dataset = {
            type: 'image',
            version: 1,
            src: isBlob ? '<base64String>' : this.getSrc(),
            width: this.getImgWidth(),
            height: this.getImgHeight(),
            title: this.getTitle(),
            altText: this.getAltText(),
            caption: this.getCaption(),
            cardWidth: this.getCardWidth(),
            href: this.getHref()
        };
        return dataset;
    }

    static importDOM() {
        const parser = new ImageParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderImageNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getSrc() {
        const self = this.getLatest();
        return self.__src;
    }

    setSrc(src) {
        const writable = this.getWritable();
        return writable.__src = src;
    }

    getTitle() {
        const self = this.getLatest();
        return self.__title;
    }

    setTitle(title) {
        const writable = this.getWritable();
        return writable.__title = title;
    }

    getHref() {
        const self = this.getLatest();
        return self.__href;
    }

    setHref(href) {
        const writable = this.getWritable();
        return writable.__href = href;
    }

    setCardWidth(cardWidth) {
        const writable = this.getWritable();
        return writable.__cardWidth = cardWidth;
    }

    getCardWidth() {
        const self = this.getLatest();
        return self.__cardWidth;
    }

    getImgWidth() {
        const self = this.getLatest();
        return self.__width;
    }

    setImgWidth(width) {
        const writable = this.getWritable();
        return writable.__width = width;
    }

    getImgHeight() {
        const self = this.getLatest();
        return self.__height;
    }

    setImgHeight(height) {
        const writable = this.getWritable();
        return writable.__height = height;
    }

    getCaption() {
        const self = this.getLatest();
        return self.__caption;
    }

    setCaption(caption) {
        const writable = this.getWritable();
        return writable.__caption = caption;
    }

    getAltText() {
        const self = this.getLatest();
        return self.__altText;
    }

    setAltText(altText) {
        const writable = this.getWritable();
        return writable.__altText = altText;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }
}

const $createImageNode = (dataset) => {
    return new ImageNode(dataset);
};

function $isImageNode(node) {
    return node instanceof ImageNode;
}

class CodeBlockParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            figure: () => ({
                conversion(domNode) {
                    if (domNode.tagName === 'FIGURE') {
                        const pre = domNode.querySelector('pre');

                        // If this figure doesn't have a pre tag in it
                        if (!pre) {
                            return null;
                        }

                        let code = pre.querySelector('code');
                        let figcaption = domNode.querySelector('figcaption');

                        // if there's no caption the pre key should pick it up
                        if (!code || !figcaption) {
                            return null;
                        }

                        let payload = {
                            code: code.textContent,
                            caption: readCaptionFromElement(domNode)
                        };

                        let preClass = pre.getAttribute('class') || '';
                        let codeClass = code.getAttribute('class') || '';
                        let langRegex = /lang(?:uage)?-(.*?)(?:\s|$)/i;
                        let languageMatches = preClass.match(langRegex) || codeClass.match(langRegex);
                        if (languageMatches) {
                            payload.language = languageMatches[1].toLowerCase();
                        }

                        const node = new self.NodeClass(payload);
                        return {node};
                    }
                    return null;
                },
                priority: 2 // falls back to pre if no caption
            }),
            pre: () => ({
                conversion(domNode) {
                    if (domNode.tagName === 'PRE') {
                        let [codeElement] = domNode.children;

                        if (codeElement && codeElement.tagName === 'CODE') {
                            let payload = {code: codeElement.textContent};
                            let preClass = domNode.getAttribute('class') || '';
                            let codeClass = codeElement.getAttribute('class') || '';
                            let langRegex = /lang(?:uage)?-(.*?)(?:\s|$)/i;
                            let languageMatches = preClass.match(langRegex) || codeClass.match(langRegex);
                            if (languageMatches) {
                                payload.language = languageMatches[1].toLowerCase();
                            }
                            const node = new self.NodeClass(payload);
                            return {node};
                        }
                    }

                    return null;
                },
                priority: 1
            })
        };
    }
}

function renderCodeBlockNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    if (!node.getCode() || node.getCode().trim() === '') {
        return document.createTextNode('');
    }

    const pre = document.createElement('pre');
    const code = document.createElement('code');

    if (node.getLanguage()) {
        code.setAttribute('class', `language-${node.getLanguage()}`);
    }

    code.appendChild(document.createTextNode(node.getCode()));
    pre.appendChild(code);

    if (node.getCaption()) {
        let figure = document.createElement('figure');
        figure.setAttribute('class', 'kg-card kg-code-card');
        figure.appendChild(pre);

        let figcaption = document.createElement('figcaption');
        figcaption.appendChild(document.createTextNode(node.getCaption()));
        figure.appendChild(figcaption);

        return figure;
    } else {
        return pre;
    }
}

const INSERT_CODE_BLOCK_COMMAND = lexical.createCommand();

class CodeBlockNode extends KoenigDecoratorNode {
    __code;
    __language;
    __caption;

    static getType() {
        return 'codeblock';
    }

    static clone(node) {
        // must use `this` so the extended class in the Editor uses the correct class when cloning
        // without needing to override this method
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {
            caption: 'html'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            code: self.__code,
            language: self.__language,
            caption: self.__caption
        };
    }

    static importJSON(serializedNode) {
        const {code, language, caption} = serializedNode;
        const node = new this({code, language, caption});
        return node;
    }

    exportJSON() {
        return {
            type: 'codeblock',
            version: 1,
            code: this.__code,
            language: this.__language,
            caption: this.__caption
        };
    }

    constructor({code, language, caption} = {}, key) {
        super(key);
        this.__code = code;
        this.__language = language;
        this.__caption = caption;
    }

    static importDOM() {
        const parser = new CodeBlockParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderCodeBlockNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        return document.createElement('div');
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getCaption() {
        const self = this.getLatest();
        return self.__caption;
    }

    setCaption(caption) {
        const self = this.getWritable();
        self.__caption = caption;
    }

    getCode() {
        const self = this.getLatest();
        return self.__code;
    }

    setCode(code) {
        const self = this.getWritable();
        self.__code = code;
    }

    getLanguage() {
        const self = this.getLatest();
        return self.__language;
    }

    setLanguage(language) {
        const self = this.getWritable();
        self.__language = language;
    }

    getTextContent() {
        const self = this.getLatest();
        return self.__code;
    }

    // should be overwritten
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        return !this.__code;
    }
}

function $createCodeBlockNode(dataset) {
    return new CodeBlockNode(dataset);
}

function $isCodeBlockNode(node) {
    return node instanceof CodeBlockNode;
}

function renderMarkdownNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    const html = markdownHtmlRenderer.render(node.getMarkdown() || '', options);

    const div = document.createElement('div');

    div.innerHTML = html;

    return div;
}

const INSERT_MARKDOWN_COMMAND = lexical.createCommand();

class MarkdownNode extends KoenigDecoratorNode {
    __markdown;

    static getType() {
        return 'markdown';
    }

    static clone(node) {
        return new this(node.getDataset(), node.__key);
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {
            markdown: 'markdown'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            markdown: self.__markdown
        };
    }

    static importJSON(serializedNode) {
        const {markdown} = serializedNode;
        const node = new this({markdown});
        return node;
    }

    exportJSON() {
        return {
            type: 'markdown',
            version: 1,
            markdown: this.getMarkdown()
        };
    }

    constructor({markdown} = {}, key) {
        super(key);
        this.__markdown = markdown;
    }

    exportDOM(options = {}) {
        const element = renderMarkdownNodeToDOM(this, options);
        return {
            element,
            type: 'inner'
        };
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getMarkdown() {
        return this.__markdown;
    }

    setMarkdown(markdown) {
        const writable = this.getWritable();
        return writable.__markdown = markdown;
    }

    // should be overwritten
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        return !this.__markdown;
    }
}

function $createMarkdownNode(dataset) {
    return new MarkdownNode(dataset);
}

function $isMarkdownNode(node) {
    return node instanceof MarkdownNode;
}

class VideoParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            figure: () => ({
                conversion(domNode) {
                    const isKgVideoCard = domNode.classList?.contains('kg-video-card');
                    if (domNode.tagName === 'FIGURE' && isKgVideoCard) {
                        const videoNode = domNode.querySelector('.kg-video-container video');
                        const durationNode = domNode.querySelector('.kg-video-duration');
                        const videoSrc = videoNode && videoNode.src;
                        const videoWidth = videoNode && videoNode.width;
                        const videoHeight = videoNode && videoNode.height;
                        const durationText = durationNode && durationNode.innerHTML.trim();
                        const captionText = readCaptionFromElement(domNode);

                        if (!videoSrc) {
                            return null;
                        }

                        const payload = {
                            src: videoSrc,
                            loop: !!videoNode.loop,
                            cardWidth: getCardWidth(videoNode)
                        };

                        if (durationText) {
                            const [minutes, seconds] = durationText.split(':');
                            try {
                                payload.duration = parseInt(minutes) * 60 + parseInt(seconds);
                            } catch (e) {
                                // ignore duration
                            }
                        }

                        if (domNode.dataset.kgThumbnail) {
                            payload.thumbnailSrc = domNode.dataset.kgThumbnail;
                        }

                        if (domNode.dataset.kgCustomThumbnail) {
                            payload.customThumbnailSrc = domNode.dataset.kgCustomThumbnail;
                        }

                        if (captionText) {
                            payload.caption = captionText;
                        }

                        if (videoWidth) {
                            payload.width = videoWidth;
                        }

                        if (videoHeight) {
                            payload.height = videoHeight;
                        }

                        const node = new self.NodeClass(payload);
                        return {node};
                    }

                    return null;
                },
                priority: 1
            })
        };
    }
}

function getCardWidth(domNode) {
    if (domNode.classList.contains('kg-width-full')) {
        return 'full';
    } else if (domNode.classList.contains('kg-width-wide')) {
        return 'wide';
    } else {
        return 'regular';
    }
}

function renderVideoNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    if (!node.getSrc() || node.getSrc().trim() === '') {
        return document.createTextNode('');
    }

    const cardClasses = getCardClasses$1(node).join(' ');

    const htmlString = options.target === 'email'
        ? emailCardTemplate$2({node, options, cardClasses})
        : cardTemplate$2({node, cardClasses});

    const element = document.createElement('div');
    element.innerHTML = htmlString.trim();

    return element.firstElementChild;
}

function cardTemplate$2({node, cardClasses}) {
    const width = node.getVideoWidth();
    const height = node.getVideoHeight();
    const posterSpacerSrc = `https://img.spacergif.org/v1/${width}x${height}/0a/spacer.png`;
    const autoplayAttr = node.getLoop() ? 'loop autoplay muted' : '';
    const thumbnailSrc = node.getCustomThumbnailSrc() || node.getThumbnailSrc();
    const hideControlsClass = node.getLoop() ? ' kg-video-hide' : '';

    return (
        `
        <figure class="${cardClasses}" data-kg-thumbnail=${node.getThumbnailSrc()} data-kg-custom-thumbnail=${node.getCustomThumbnailSrc()}>
            <div class="kg-video-container">
                <video
                    src="${node.getSrc()}"
                    poster="${posterSpacerSrc}"
                    width="${width}"
                    height="${height}"
                    ${autoplayAttr}
                    playsinline
                    preload="metadata"
                    style="background: transparent url('${thumbnailSrc}') 50% 50% / cover no-repeat;"
                ></video>
                <div class="kg-video-overlay">
                    <button class="kg-video-large-play-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                            <path d="M23.14 10.608 2.253.164A1.559 1.559 0 0 0 0 1.557v20.887a1.558 1.558 0 0 0 2.253 1.392L23.14 13.393a1.557 1.557 0 0 0 0-2.785Z"/>
                        </svg>
                    </button>
                </div>
                <div class="kg-video-player-container${hideControlsClass}">
                    <div class="kg-video-player">
                        <button class="kg-video-play-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path d="M23.14 10.608 2.253.164A1.559 1.559 0 0 0 0 1.557v20.887a1.558 1.558 0 0 0 2.253 1.392L23.14 13.393a1.557 1.557 0 0 0 0-2.785Z"></path>
                            </svg>
                        </button>
                        <button class="kg-video-pause-icon kg-video-hide">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <rect x="3" y="1" width="7" height="22" rx="1.5" ry="1.5"></rect>
                                <rect x="14" y="1" width="7" height="22" rx="1.5" ry="1.5"></rect>
                            </svg>
                        </button>
                        <span class="kg-video-current-time">0:00</span>
                        <div class="kg-video-time">
                            /<span class="kg-video-duration">${node.getFormattedDuration()}</span>
                        </div>
                        <input type="range" class="kg-video-seek-slider" max="100" value="0">
                        <button class="kg-video-playback-rate">1&#215;</button>
                        <button class="kg-video-unmute-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path d="M15.189 2.021a9.728 9.728 0 0 0-7.924 4.85.249.249 0 0 1-.221.133H5.25a3 3 0 0 0-3 3v2a3 3 0 0 0 3 3h1.794a.249.249 0 0 1 .221.133 9.73 9.73 0 0 0 7.924 4.85h.06a1 1 0 0 0 1-1V3.02a1 1 0 0 0-1.06-.998Z"></path>
                            </svg>
                        </button>
                        <button class="kg-video-mute-icon kg-video-hide">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path d="M16.177 4.3a.248.248 0 0 0 .073-.176v-1.1a1 1 0 0 0-1.061-1 9.728 9.728 0 0 0-7.924 4.85.249.249 0 0 1-.221.133H5.25a3 3 0 0 0-3 3v2a3 3 0 0 0 3 3h.114a.251.251 0 0 0 .177-.073ZM23.707 1.706A1 1 0 0 0 22.293.292l-22 22a1 1 0 0 0 0 1.414l.009.009a1 1 0 0 0 1.405-.009l6.63-6.631A.251.251 0 0 1 8.515 17a.245.245 0 0 1 .177.075 10.081 10.081 0 0 0 6.5 2.92 1 1 0 0 0 1.061-1V9.266a.247.247 0 0 1 .073-.176Z"></path>
                            </svg>
                        </button>
                        <input type="range" class="kg-video-volume-slider" max="100" value="100"/>
                    </div>
                </div>
            </div>
            ${node.getCaption() ? `<figcaption>${node.getCaption()}</figcaption>` : ''}
        </figure>
    `
    );
}

function emailCardTemplate$2({node, options, cardClasses}) {
    const thumbnailSrc = node.getCustomThumbnailSrc() || node.getThumbnailSrc();
    const emailTemplateMaxWidth = 600;
    const aspectRatio = node.getVideoWidth() / node.getVideoHeight();
    const emailSpacerWidth = Math.round(emailTemplateMaxWidth / 4);
    const emailSpacerHeight = Math.round(emailTemplateMaxWidth / aspectRatio);
    const posterSpacerSrc = `https://img.spacergif.org/v1/${emailSpacerWidth}x${emailSpacerHeight}/0a/spacer.png`;
    const outlookCircleLeft = Math.round((emailTemplateMaxWidth / 2) - 39);
    const outlookCircleTop = Math.round((emailSpacerHeight / 2) - 39);
    const outlookPlayLeft = Math.round((emailTemplateMaxWidth / 2) - 11);
    const outlookPlayTop = Math.round((emailSpacerHeight / 2) - 17);

    return (
        `
         <figure class="${cardClasses}">
            <!--[if !mso !vml]-->
            <a class="kg-video-preview" href="${options.postUrl}" aria-label="Play video" style="mso-hide: all">
                <table
                    cellpadding="0"
                    cellspacing="0"
                    border="0"
                    width="100%"
                    background="${thumbnailSrc}"
                    role="presentation"
                    style="background: url('${thumbnailSrc}') left top / cover; mso-hide: all"
                >
                    <tr style="mso-hide: all">
                        <td width="25%" style="visibility: hidden; mso-hide: all">
                            <img src="${posterSpacerSrc}" alt="" width="100%" border="0" style="height: auto; opacity: 0; visibility: hidden; mso-hide: all;">
                        </td>
                        <td width="50%" align="center" valign="middle" style="vertical-align: middle; mso-hide: all;">
                            <div class="kg-video-play-button" style="mso-hide: all"><div style="mso-hide: all"></div></div>
                        </td>
                        <td width="25%" style="mso-hide: all">&nbsp;</td>
                    </tr>
                </table>
            </a>
            <!--[endif]-->

            <!--[if vml]>
            <v:group xmlns:v="urn:schemas-microsoft-com:vml" xmlns:w="urn:schemas-microsoft-com:office:word" coordsize="${emailTemplateMaxWidth},${emailSpacerHeight}" coordorigin="0,0" href="${options.postUrl}" style="width:${emailTemplateMaxWidth}px;height:${emailSpacerHeight}px;">
                <v:rect fill="t" stroked="f" style="position:absolute;width:${emailTemplateMaxWidth};height:${emailSpacerHeight};"><v:fill src="${thumbnailSrc}" type="frame"/></v:rect>
                <v:oval fill="t" strokecolor="white" strokeweight="4px" style="position:absolute;left:${outlookCircleLeft};top:${outlookCircleTop};width:78;height:78"><v:fill color="black" opacity="30%" /></v:oval>
                <v:shape coordsize="24,32" path="m,l,32,24,16,xe" fillcolor="white" stroked="f" style="position:absolute;left:${outlookPlayLeft};top:${outlookPlayTop};width:30;height:34;" />
            </v:group>
            <![endif]-->

            ${node.getCaption() ? `<figcaption>${node.getCaption()}</figcaption>` : ''}
        </figure>
        `
    );
}

function getCardClasses$1(node) {
    let cardClasses = ['kg-card kg-video-card'];

    if (node.getCardWidth()) {
        cardClasses.push(`kg-width-${node.getCardWidth()}`);
    }
    if (node.getCaption()) {
        cardClasses.push(`kg-card-hascaption`);
    }

    return cardClasses;
}

const INSERT_VIDEO_COMMAND = lexical.createCommand();
const NODE_TYPE$6 = 'video';

class VideoNode extends KoenigDecoratorNode {
    // payload properties
    __src;
    __caption;
    __width;
    __height;
    __duration;
    __thumbnailSrc;
    __customThumbnailSrc;
    __cardWidth;
    __loop;

    static getType() {
        return NODE_TYPE$6;
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {
            src: 'url',
            thumbnailSrc: 'url',
            customThumbnailSrc: 'url',
            caption: 'html'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            src: self.__src,
            caption: self.__caption,
            width: self.__width,
            height: self.__height,
            duration: self.__duration,
            thumbnailSrc: self.__thumbnailSrc,
            customThumbnailSrc: self.__customThumbnailSrc,
            cardWidth: self.__cardWidth,
            loop: self.__loop
        };
    }

    constructor({src, caption, width, height, duration, thumbnailSrc, customThumbnailSrc, cardWidth, loop} = {}, key) {
        super(key);
        this.__src = src || '';
        this.__caption = caption || '';
        this.__width = width || null;
        this.__height = height || null;
        this.__duration = duration || 0;
        this.__thumbnailSrc = thumbnailSrc || '';
        this.__customThumbnailSrc = customThumbnailSrc || '';
        this.__cardWidth = cardWidth || 'regular';
        this.__loop = !!loop;
    }

    static importJSON(serializedNode) {
        const {src, caption, width, height, duration, thumbnailSrc, customThumbnailSrc, cardWidth, loop} = serializedNode;
        const node = new this({
            src,
            caption,
            width,
            height,
            duration,
            thumbnailSrc,
            customThumbnailSrc,
            cardWidth,
            loop
        });
        return node;
    }

    exportJSON() {
        // checks if src is a data string
        const src = this.getSrc();
        const isBlob = src.startsWith('data:');
        const dataset = {
            type: NODE_TYPE$6,
            version: 1,
            src: isBlob ? '<base64String>' : this.getSrc(),
            caption: this.getCaption(),
            width: this.getVideoWidth(),
            height: this.getVideoHeight(),
            duration: this.getDuration(),
            thumbnailSrc: this.getThumbnailSrc(),
            customThumbnailSrc: this.getCustomThumbnailSrc(),
            cardWidth: this.getCardWidth(),
            loop: this.getLoop()
        };
        return dataset;
    }

    static importDOM() {
        const parser = new VideoParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderVideoNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getSrc() {
        const self = this.getLatest();
        return self.__src;
    }

    setSrc(src) {
        const writable = this.getWritable();
        return writable.__src = src;
    }

    getCaption() {
        const self = this.getLatest();
        return self.__caption;
    }

    setCaption(caption) {
        const writable = this.getWritable();
        return writable.__caption = caption;
    }

    getVideoWidth() {
        const self = this.getLatest();
        return self.__width;
    }

    setVideoWidth(width) {
        const writable = this.getWritable();
        return writable.__width = width;
    }

    getVideoHeight() {
        const self = this.getLatest();
        return self.__height;
    }

    setVideoHeight(height) {
        const writable = this.getWritable();
        return writable.__height = height;
    }

    getDuration() {
        const self = this.getLatest();
        return self.__duration;
    }

    getFormattedDuration() {
        const minutes = Math.floor(this.getDuration() / 60);
        const seconds = Math.floor(this.getDuration() - (minutes * 60));
        const paddedSeconds = String(seconds).padStart(2, '0');
        const formattedDuration = `${minutes}:${paddedSeconds}`;
        return formattedDuration;
    }

    setDuration(duration) {
        const writable = this.getWritable();
        return writable.__duration = duration;
    }

    getThumbnailSrc() {
        const self = this.getLatest();
        return self.__thumbnailSrc;
    }

    setThumbnailSrc(thumbnailSrc) {
        const writable = this.getWritable();
        return writable.__thumbnailSrc = thumbnailSrc;
    }

    getCustomThumbnailSrc() {
        const self = this.getLatest();
        return self.__customThumbnailSrc;
    }

    setCustomThumbnailSrc(customThumbnailSrc) {
        const writable = this.getWritable();
        return writable.__customThumbnailSrc = customThumbnailSrc;
    }

    setCardWidth(cardWidth) {
        const writable = this.getWritable();
        return writable.__cardWidth = cardWidth;
    }

    getCardWidth() {
        const self = this.getLatest();
        return self.__cardWidth;
    }

    getLoop() {
        const self = this.getLatest();
        return self.__loop;
    }

    setLoop(loop) {
        const writable = this.getWritable();
        return writable.__loop = loop;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        return !this.__src;
    }
}

const $createVideoNode = (dataset) => {
    return new VideoNode(dataset);
};

function $isVideoNode(node) {
    return node instanceof VideoNode;
}

class AudioParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            div: (nodeElem) => {
                const isKgAudioCard = nodeElem.classList?.contains('kg-audio-card');
                if (nodeElem.tagName === 'DIV' && isKgAudioCard) {
                    return {
                        conversion(domNode) {
                            const titleNode = domNode?.querySelector('.kg-audio-title');
                            const audioNode = domNode?.querySelector('.kg-audio-player-container audio');
                            const durationNode = domNode?.querySelector('.kg-audio-duration');
                            const thumbnailNode = domNode?.querySelector('.kg-audio-thumbnail');
                            const title = titleNode && titleNode.innerHTML.trim();
                            const audioSrc = audioNode && audioNode.src;
                            const thumbnailSrc = thumbnailNode && thumbnailNode.src;
                            const durationText = durationNode && durationNode.innerHTML.trim();
                            const payload = {
                                src: audioSrc,
                                title: title
                            };
                            if (thumbnailSrc) {
                                payload.thumbnailSrc = thumbnailSrc;
                            }

                            if (durationText) {
                                const [minutes, seconds = 0] = durationText.split(':');
                                try {
                                    payload.duration = parseInt(minutes) * 60 + parseInt(seconds);
                                } catch (e) {
                                    // ignore duration
                                }
                            }

                            const node = new self.NodeClass(payload);
                            return {node};
                        },
                        priority: 1
                    };
                }
                return null;
            }
        };
    }
}

function renderAudioNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    if (!node.getSrc() || node.getSrc().trim() === '') {
        return document.createTextNode('');
    }

    return frontendTemplate$2(node, document);
}

function frontendTemplate$2(node, document) {
    let thumbnailCls = 'kg-audio-thumbnail';
    let emptyThumbnailCls = 'kg-audio-thumbnail placeholder';
    if (!node.getThumbnailSrc()) {
        thumbnailCls += ' kg-audio-hide';
    } else {
        emptyThumbnailCls += ' kg-audio-hide';
    }

    const cardDiv = document.createElement('div');
    cardDiv.setAttribute('class', 'kg-card kg-audio-card');
    const img = document.createElement('img');
    img.src = node.getThumbnailSrc();
    img.alt = 'audio-thumbnail';
    img.setAttribute('class', thumbnailCls);
    cardDiv.appendChild(img);

    const emptyThumbnailDiv = document.createElement('div');
    emptyThumbnailDiv.setAttribute('class', emptyThumbnailCls);
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', '24');
    svg.setAttribute('height', '24');
    svg.setAttribute('fill', 'none');
    const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path1.setAttribute('fill-rule', 'evenodd');
    path1.setAttribute('clip-rule', 'evenodd');
    path1.setAttribute('d', 'M7.5 15.33a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Zm-2.25.75a2.25 2.25 0 1 1 4.5 0 2.25 2.25 0 0 1-4.5 0ZM15 13.83a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Zm-2.25.75a2.25 2.25 0 1 1 4.5 0 2.25 2.25 0 0 1-4.5 0Z');
    svg.appendChild(path1);
    const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path2.setAttribute('fill-rule', 'evenodd');
    path2.setAttribute('clip-rule', 'evenodd');
    path2.setAttribute('d', 'M14.486 6.81A2.25 2.25 0 0 1 17.25 9v5.579a.75.75 0 0 1-1.5 0v-5.58a.75.75 0 0 0-.932-.727.755.755 0 0 1-.059.013l-4.465.744a.75.75 0 0 0-.544.72v6.33a.75.75 0 0 1-1.5 0v-6.33a2.25 2.25 0 0 1 1.763-2.194l4.473-.746Z');
    svg.appendChild(path2);
    const path3 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path3.setAttribute('fill-rule', 'evenodd');
    path3.setAttribute('clip-rule', 'evenodd');
    path3.setAttribute('d', 'M3 1.5a.75.75 0 0 0-.75.75v19.5a.75.75 0 0 0 .75.75h18a.75.75 0 0 0 .75-.75V5.133a.75.75 0 0 0-.225-.535l-.002-.002-3-2.883A.75.75 0 0 0 18 1.5H3ZM1.409.659A2.25 2.25 0 0 1 3 0h15a2.25 2.25 0 0 1 1.568.637l.003.002 3 2.883a2.25 2.25 0 0 1 .679 1.61V21.75A2.25 2.25 0 0 1 21 24H3a2.25 2.25 0 0 1-2.25-2.25V2.25c0-.597.237-1.169.659-1.591Z');
    svg.appendChild(path3);
    emptyThumbnailDiv.appendChild(svg);

    cardDiv.appendChild(emptyThumbnailDiv);

    const audioPlayerContainer = document.createElement('div');
    audioPlayerContainer.setAttribute('class', 'kg-audio-player-container');

    const audioElement = document.createElement('audio');
    audioElement.setAttribute('src', node.getSrc());
    audioElement.setAttribute('preload', 'metadata');
    audioPlayerContainer.appendChild(audioElement);

    const audioTitle = document.createElement('div');
    audioTitle.setAttribute('class', 'kg-audio-title');
    audioTitle.textContent = node.getTitle();
    audioPlayerContainer.appendChild(audioTitle);

    const audioPlayer = document.createElement('div');
    audioPlayer.setAttribute('class', 'kg-audio-player');
    const audioPlayIcon = document.createElement('button');
    audioPlayIcon.setAttribute('class', 'kg-audio-play-icon');
    const audioPlayIconSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    audioPlayIconSvg.setAttribute('viewBox', '0 0 24 24');
    const playPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    playPath.setAttribute('d', 'M23.14 10.608 2.253.164A1.559 1.559 0 0 0 0 1.557v20.887a1.558 1.558 0 0 0 2.253 1.392L23.14 13.393a1.557 1.557 0 0 0 0-2.785Z');
    audioPlayIconSvg.appendChild(playPath);
    audioPlayIcon.appendChild(audioPlayIconSvg);
    audioPlayer.appendChild(audioPlayIcon);

    const audioPauseIcon = document.createElement('button');
    audioPauseIcon.setAttribute('class', 'kg-audio-pause-icon kg-audio-hide');
    const audioPauseIconSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    audioPauseIconSvg.setAttribute('viewBox', '0 0 24 24');
    const rectSvg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rectSvg.setAttribute('x', '3');
    rectSvg.setAttribute('y', '1');
    rectSvg.setAttribute('width', '7');
    rectSvg.setAttribute('height', '22');
    rectSvg.setAttribute('rx', '1.5');
    rectSvg.setAttribute('ry', '1.5');
    audioPauseIconSvg.appendChild(rectSvg);
    const rectSvg2 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rectSvg2.setAttribute('x', '14');
    rectSvg2.setAttribute('y', '1');
    rectSvg2.setAttribute('width', '7');
    rectSvg2.setAttribute('height', '22');
    rectSvg2.setAttribute('rx', '1.5');
    rectSvg2.setAttribute('ry', '1.5');
    audioPauseIconSvg.appendChild(rectSvg2);
    audioPauseIcon.appendChild(audioPauseIconSvg);
    audioPlayer.appendChild(audioPauseIcon);

    const audioDuration = document.createElement('span');
    audioDuration.setAttribute('class', 'kg-audio-current-time');
    audioDuration.textContent = '0:00';
    audioPlayer.appendChild(audioDuration);

    const audioDurationTotal = document.createElement('div');
    audioDurationTotal.setAttribute('class', 'kg-audio-time');
    audioDurationTotal.textContent = '/';
    const audioDUrationNode = document.createElement('span');
    audioDUrationNode.setAttribute('class', 'kg-audio-duration');
    audioDUrationNode.textContent = node.getDuration();
    audioDurationTotal.appendChild(audioDUrationNode);
    audioPlayer.appendChild(audioDurationTotal);

    const audioSlider = document.createElement('input');
    audioSlider.setAttribute('type', 'range');
    audioSlider.setAttribute('class', 'kg-audio-seek-slider');
    audioSlider.setAttribute('max', '100');
    audioSlider.setAttribute('value', '0');
    audioPlayer.appendChild(audioSlider);

    const playbackRate = document.createElement('button');
    playbackRate.setAttribute('class', 'kg-audio-playback-rate');
    playbackRate.innerHTML = '1&#215;'; // innerHTML not textContent because we need the HTML entity
    audioPlayer.appendChild(playbackRate);

    const unmuteIcon = document.createElement('button');
    unmuteIcon.setAttribute('class', 'kg-audio-unmute-icon');
    const unmuteIconSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    unmuteIconSvg.setAttribute('viewBox', '0 0 24 24');
    const unmutePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    unmutePath.setAttribute('d', 'M15.189 2.021a9.728 9.728 0 0 0-7.924 4.85.249.249 0 0 1-.221.133H5.25a3 3 0 0 0-3 3v2a3 3 0 0 0 3 3h1.794a.249.249 0 0 1 .221.133 9.73 9.73 0 0 0 7.924 4.85h.06a1 1 0 0 0 1-1V3.02a1 1 0 0 0-1.06-.998Z');
    unmuteIconSvg.appendChild(unmutePath);
    unmuteIcon.appendChild(unmuteIconSvg);
    audioPlayer.appendChild(unmuteIcon);

    const muteIcon = document.createElement('button');
    muteIcon.setAttribute('class', 'kg-audio-mute-icon kg-audio-hide');
    const muteIconSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    muteIconSvg.setAttribute('viewBox', '0 0 24 24');
    const mutePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    mutePath.setAttribute('d', 'M16.177 4.3a.248.248 0 0 0 .073-.176v-1.1a1 1 0 0 0-1.061-1 9.728 9.728 0 0 0-7.924 4.85.249.249 0 0 1-.221.133H5.25a3 3 0 0 0-3 3v2a3 3 0 0 0 3 3h.114a.251.251 0 0 0 .177-.073ZM23.707 1.706A1 1 0 0 0 22.293.292l-22 22a1 1 0 0 0 0 1.414l.009.009a1 1 0 0 0 1.405-.009l6.63-6.631A.251.251 0 0 1 8.515 17a.245.245 0 0 1 .177.075 10.081 10.081 0 0 0 6.5 2.92 1 1 0 0 0 1.061-1V9.266a.247.247 0 0 1 .073-.176Z');
    muteIconSvg.appendChild(mutePath);
    muteIcon.appendChild(muteIconSvg);
    audioPlayer.appendChild(muteIcon);

    const volumeSlider = document.createElement('input');
    volumeSlider.setAttribute('type', 'range');
    volumeSlider.setAttribute('class', 'kg-audio-volume-slider');
    volumeSlider.setAttribute('max', '100');
    volumeSlider.setAttribute('value', '100');
    audioPlayer.appendChild(volumeSlider);

    audioPlayerContainer.appendChild(audioPlayer);
    cardDiv.appendChild(audioPlayerContainer);

    return cardDiv;
}

const INSERT_AUDIO_COMMAND = lexical.createCommand();
const NODE_TYPE$5 = 'audio';

class AudioNode extends KoenigDecoratorNode {
    // payload properties
    __src;
    __title;
    __duration;
    __mimeType;
    __thumbnailSrc;

    static getType() {
        return NODE_TYPE$5;
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {
            src: 'url'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            src: self.__src,
            title: self.__title,
            duration: self.__duration,
            mimeType: self.__mimeType,
            thumbnailSrc: self.__thumbnailSrc
        };
    }

    constructor({src, title, duration, thumbnailSrc, mimeType} = {}, key) {
        super(key);
        this.__src = src || '';
        this.__title = title || '';
        this.__duration = duration || 0;
        this.__mimeType = mimeType || '';
        this.__thumbnailSrc = thumbnailSrc || '';
    }

    static importJSON(serializedNode) {
        const {src, title, duration, mimeType, thumbnailSrc} = serializedNode;
        const node = new this({
            src,
            title,
            mimeType,
            duration,
            thumbnailSrc
        });
        return node;
    }

    exportJSON() {
        // checks if src is a data string
        const src = this.getSrc();
        const isBlob = src.startsWith('data:');
        const dataset = {
            type: NODE_TYPE$5,
            version: 1,
            src: isBlob ? '<base64String>' : this.getSrc(),
            title: this.getTitle(),
            mimeType: this.getMimeType(),
            duration: this.getDuration(),
            thumbnailSrc: this.getThumbnailSrc()
        };
        return dataset;
    }

    static importDOM() {
        const parser = new AudioParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderAudioNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getSrc() {
        const self = this.getLatest();
        return self.__src;
    }

    setSrc(src) {
        const writable = this.getWritable();
        return writable.__src = src;
    }

    getTitle() {
        const self = this.getLatest();
        return self.__title;
    }

    setTitle(title) {
        const writable = this.getWritable();
        return writable.__title = title;
    }

    getDuration() {
        const self = this.getLatest();
        return self.__duration;
    }

    setDuration(duration) {
        const writable = this.getWritable();
        return writable.__duration = duration;
    }

    getMimeType() {
        const self = this.getLatest();
        return self.__mimeType;
    }

    setMimeType(mimeType) {
        const writable = this.getWritable();
        return writable.__mimeType = mimeType;
    }

    getThumbnailSrc() {
        const self = this.getLatest();
        return self.__thumbnailSrc;
    }

    setThumbnailSrc(thumbnailSrc) {
        const writable = this.getWritable();
        return writable.__thumbnailSrc = thumbnailSrc;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        return !this.__src;
    }
}

const $createAudioNode = (dataset) => {
    return new AudioNode(dataset);
};

function $isAudioNode(node) {
    return node instanceof AudioNode;
}

function renderCalloutNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    /* c8 ignore stop */

    const document = options.createDocument();

    const element = document.createElement('div');
    element.classList.add('kg-card', 'kg-callout-card', `kg-callout-card-${node.getBackgroundColor()}`);
    if (node.getHasEmoji()) {
        const emojiElement = document.createElement('div');
        emojiElement.classList.add('kg-callout-emoji');
        emojiElement.textContent = node.getEmojiValue();
        element.appendChild(emojiElement);
    }
    const textElement = document.createElement('div');
    textElement.classList.add('kg-callout-text');
    textElement.innerHTML = node.getText();
    element.appendChild(textElement);
    return element;
}

const getColorTag = (nodeElem) => {
    const colorClass = nodeElem.classList?.value?.match(/kg-callout-card-(\w+)/);
    return colorClass && colorClass[1];
};

class CalloutParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            div: (nodeElem) => {
                const isKgCalloutCard = nodeElem.classList?.contains('kg-callout-card');
                if (nodeElem.tagName === 'DIV' && isKgCalloutCard) {
                    return {
                        conversion(domNode) {
                            const textNode = domNode?.querySelector('.kg-callout-text');
                            const emojiNode = domNode?.querySelector('.kg-callout-emoji');
                            const color = getColorTag(domNode);

                            const payload = {
                                text: textNode && textNode.innerHTML.trim(),
                                hasEmoji: emojiNode ? true : false,
                                emojiValue: emojiNode && emojiNode.innerHTML.trim(),
                                backgroundColor: color
                            };

                            const node = new self.NodeClass(payload);
                            return {node};
                        },
                        priority: 1
                    };
                }
                return null;
            }
        };
    }
}

const INSERT_CALLOUT_COMMAND = lexical.createCommand();
const NODE_TYPE$4 = 'callout';

class CalloutNode extends KoenigDecoratorNode {
    // payload properties
    __text;
    __hasEmoji;
    __emojiValue;
    __backgroundColor;

    static getType() {
        return NODE_TYPE$4;
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    getDataset() {
        const self = this.getLatest();
        return {
            text: self.__text,
            hasEmoji: self.__hasEmoji,
            emojiValue: self.__emojiValue,
            backgroundColor: self.__backgroundColor
        };
    }

    constructor({text, hasEmoji = true, emojiValue, backgroundColor} = {}, key) {
        super(key);
        this.__text = text || '';
        this.__hasEmoji = hasEmoji;
        this.__emojiValue = emojiValue || '💡';
        this.__backgroundColor = backgroundColor || 'blue';
    }

    static importJSON(serializedNode) {
        const {text, hasEmoji, backgroundColor, emojiValue} = serializedNode;
        return new this({
            text,
            hasEmoji,
            emojiValue,
            backgroundColor
        });
    }

    exportJSON() {
        const dataset = {
            type: NODE_TYPE$4,
            version: 1,
            text: this.getText(),
            hasEmoji: this.__hasEmoji,
            emojiValue: this.__emojiValue,
            backgroundColor: this.__backgroundColor
        };
        return dataset;
    }

    static importDOM() {
        const parser = new CalloutParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderCalloutNodeToDOM(this, options);
        return {element};
    }

    createDom() {
        const element = document.createElement('div');
        return element;
    }

    updateDom() {
        return false;
    }

    isInline() {
        return false;
    }

    getText() {
        const self = this.getLatest();
        return self.__text;
    }

    setText(text) {
        const writeable = this.getWritable();
        writeable.__text = text;
    }

    getBackgroundColor() {
        const self = this.getLatest();
        return self.__backgroundColor;
    }

    setBackgroundColor(color) {
        const writeable = this.getWritable();
        writeable.__backgroundColor = color;
    }

    getHasEmoji() {
        const self = this.getLatest();
        return self.__hasEmoji;
    }

    setHasEmoji(hasEmoji) {
        const writeable = this.getWritable();
        writeable.__hasEmoji = hasEmoji;
    }

    getEmojiValue() {
        const self = this.getLatest();
        return self.__emojiValue;
    }

    setEmojiValue(emojiValue) {
        const writeable = this.getWritable();
        writeable.__emojiValue = emojiValue;
    }

    decorate() {
        return '';
    }

    hasEditMode() {
        return true;
    }
}

function $isCalloutNode(node) {
    return node instanceof CalloutNode;
}

const $createCalloutNode = (dataset) => {
    return new CalloutNode(dataset);
};

class AsideParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            aside: () => ({
                conversion() {
                    const node = new self.NodeClass();
                    return {node};
                },
                priority: 0
            })
        };
    }
}

function renderAsideToDOM(_, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    const aside = document.createElement('aside');
    return aside;
}

class AsideNode extends lexical.ElementNode {
    static getType() {
        return 'aside';
    }

    static clone(node) {
        return new this(
            node.__key
        );
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {};
    }

    constructor(key) {
        super(key);
    }

    static importJSON(serializedNode) {
        const node = new this();
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        return node;
    }

    exportJSON() {
        const dataset = {
            ...super.exportJSON(),
            type: 'aside',
            version: 1
        };
        return dataset;
    }

    static importDOM() {
        const parser = new AsideParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderAsideToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */
}

function $createAsideNode() {
    return new AsideNode();
}

function $isAsideNode(node) {
    return node instanceof AsideNode;
}

function renderHorizontalRuleToDOM(_, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    const hr = document.createElement('hr');
    return hr;
}

class HorizontalRuleParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            hr: () => ({
                conversion() {
                    const node = new self.NodeClass();
                    return {node};
                },
                priority: 0
            })
        };
    }
}

const INSERT_HORIZONTAL_RULE_COMMAND = lexical.createCommand();

class HorizontalRuleNode extends KoenigDecoratorNode {
    static getType() {
        return 'horizontalrule';
    }

    static clone(node) {
        return new this(
            node.__key
        );
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {};
    }

    constructor(key) {
        super(key);
    }

    static importJSON() {
        const node = new this();
        return node;
    }

    exportJSON() {
        const dataset = {
            type: 'horizontalrule',
            version: 1
        };
        return dataset;
    }

    static importDOM() {
        const parser = new HorizontalRuleParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderHorizontalRuleToDOM(this, options);
        return {element};
    }

    getTextContent() {
        return '\n';
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }
}

function $createHorizontalRuleNode() {
    return new HorizontalRuleNode();
}

function $isHorizontalRuleNode(node) {
    return node instanceof HorizontalRuleNode;
}

function renderHtmlNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    const html = node.getHtml() || '';

    const div = document.createElement('div');

    div.innerHTML = html;

    return div;
}

class HtmlParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            '#comment': () => {
                return {
                    conversion(domNode) {
                        const isCommentNode = domNode.nodeType === 8;
                        if (isCommentNode && domNode.nodeValue.trim() === 'kg-card-begin: html') {
                            let html = [];
                            let nextNode = domNode.nextSibling;

                            while (nextNode && !isHtmlEndComment(nextNode)) {
                                let currentNode = nextNode;
                                html.push(currentNode.outerHTML);
                                nextNode = currentNode.nextSibling;
                                // remove nodes as we go so that they don't go through the parser
                                currentNode.remove();
                            }

                            let payload = {html: html.join('\n').trim()};
                            const node = new self.NodeClass(payload);
                            return {node};
                        }

                        return null;
                    },
                    priority: 0
                };
            }
        };
    }
}

function isHtmlEndComment(node) {
    return node && node.nodeType === 8 && node.nodeValue === 'kg-card-end: html';
}

const INSERT_HTML_COMMAND = lexical.createCommand();

class HtmlNode extends KoenigDecoratorNode {
    __html;

    static getType() {
        return 'html';
    }

    static clone(node) {
        return new this(node.getDataset(), node.__key);
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {
            html: 'html'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            html: self.__html
        };
    }

    static importJSON(serializedNode) {
        const {html} = serializedNode;
        const node = new this({html});
        return node;
    }

    exportJSON() {
        return {
            type: 'html',
            version: 1,
            html: this.getHtml()
        };
    }

    constructor({html} = {}, key) {
        super(key);
        this.__html = html;
    }

    static importDOM() {
        const parser = new HtmlParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderHtmlNodeToDOM(this, options);
        return {
            element,
            type: 'inner'
        };
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getHtml() {
        const self = this.getLatest();
        return self.__html;
    }

    setHtml(html) {
        const writable = this.getWritable();
        return writable.__html = html;
    }

    // should be overwritten
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        return !this.__html;
    }
}

function $createHtmlNode(dataset) {
    return new HtmlNode(dataset);
}

function $isHtmlNode(node) {
    return node instanceof HtmlNode;
}

class ToggleParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            div: () => ({
                conversion(domNode) {
                    const isKgToggleCard = domNode.classList?.contains('kg-toggle-card');
                    if (domNode.tagName === 'DIV' && isKgToggleCard) {
                        const headerNode = domNode.querySelector('.kg-toggle-heading-text');
                        const header = headerNode.textContent;

                        const contentNode = domNode.querySelector('.kg-toggle-content');
                        const content = contentNode.textContent;

                        const payload = {
                            header,
                            content
                        };

                        const node = new self.NodeClass(payload);
                        return {node};
                    }

                    return null;
                },
                priority: 1
            })
        };
    }
}

function cardTemplate$1({node}) {
    const content = node.getContent();
    const header = node.getHeader();

    return (
        `
        <div class="kg-card kg-toggle-card" data-kg-toggle-state="close">
            <div class="kg-toggle-heading">
                <h4 class="kg-toggle-heading-text">${header}</h4>
                <button class="kg-toggle-card-icon">
                    <svg id="Regular" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path class="cls-1" d="M23.25,7.311,12.53,18.03a.749.749,0,0,1-1.06,0L.75,7.311"></path>
                    </svg>
                </button>
            </div>
            <div class="kg-toggle-content">${content}</div>
        </div>
        `
    );
}

function emailCardTemplate$1({node}) {
    const content = node.getContent();
    const header = node.getHeader();

    return (
        `
        <div style="background: transparent;
        border: 1px solid rgba(124, 139, 154, 0.25); border-radius: 4px; padding: 20px; margin-bottom: 1.5em;">
            <h4 style="font-size: 1.375rem; font-weight: 600; margin-bottom: 8px; margin-top:0px">${header}</h4>
            <div style="font-size: 1rem; line-height: 1.5; margin-bottom: -1.5em;">${content}</div>
        </div>
        `
    );
}

function renderToggleNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    const htmlString = options.target === 'email'
        ? emailCardTemplate$1({node})
        : cardTemplate$1({node});

    const element = document.createElement('div');
    element.innerHTML = htmlString.trim();

    return element.firstElementChild;
}

const INSERT_TOGGLE_COMMAND = lexical.createCommand();
const NODE_TYPE$3 = 'toggle';

class ToggleNode extends KoenigDecoratorNode {
    // payload properties
    __content;
    __header;

    static getType() {
        return NODE_TYPE$3;
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    static get urlTransformMap() {
        return {
            content: 'html',
            header: 'html'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            content: self.__content,
            header: self.__header
        };
    }

    constructor({content, header} = {}, key) {
        super(key);
        this.__content = content || '';
        this.__header = header || '';
    }

    static importJSON(serializedNode) {
        const {content, header} = serializedNode;
        return new this({
            content,
            header
        });
    }

    exportJSON() {
        const dataset = {
            type: NODE_TYPE$3,
            version: 1,
            content: this.getContent(),
            header: this.getHeader()
        };
        return dataset;
    }

    static importDOM() {
        const parser = new ToggleParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderToggleNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        return document.createElement('div');
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getContent() {
        const self = this.getLatest();
        return self.__content;
    }

    setContent(content) {
        const writable = this.getWritable();
        return writable.__content = content;
    }

    getHeader() {
        const self = this.getLatest();
        return self.__header;
    }

    setHeader(header) {
        const writable = this.getWritable();
        return writable.__header = header;
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        return !this.__header && !this.__content;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }
}

const $createToggleNode = (dataset) => {
    return new ToggleNode(dataset);
};

function $isToggleNode(node) {
    return node instanceof ToggleNode;
}

class ButtonParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            div: (nodeElem) => {
                const isButtonCard = nodeElem.classList?.contains('kg-button-card');
                if (nodeElem.tagName === 'DIV' && isButtonCard) {
                    return {
                        conversion(domNode) {
                            const alignmentClass = nodeElem.className.match(/kg-align-(left|center)/);
                            
                            let alignment;
                            if (alignmentClass) {
                                alignment = alignmentClass[1];
                            }

                            const buttonNode = domNode?.querySelector('.kg-btn');
                            const buttonUrl = buttonNode.href;
                            const buttonText = buttonNode.textContent;

                            const payload = {
                                buttonText: buttonText,
                                alignment: alignment,
                                buttonUrl: buttonUrl
                            };

                            const node = new self.NodeClass(payload);
                            return {node};
                        },
                        priority: 1
                    };
                }
                return null;
            }
        };
    }
}

function renderButtonNodeToDOM(node, options = {}) {
    const document = options.createDocument();

    if (!node.getButtonUrl() || node.getButtonUrl().trim() === '') {
        return document.createTextNode('');
    }

    if (options.target === 'email') {
        return emailTemplate$1(node, document);
    } else {
        return frontendTemplate$1(node, document);
    }
}

function frontendTemplate$1(node, document) {
    const cardClasses = getCardClasses(node);

    const cardDiv = document.createElement('div');
    cardDiv.setAttribute('class', cardClasses);

    const button = document.createElement('a');
    button.setAttribute('href', node.getButtonUrl());
    button.setAttribute('class', 'kg-btn kg-btn-accent');
    button.textContent = node.getButtonText() || 'Button Title';

    cardDiv.appendChild(button);
    return cardDiv;
}

function emailTemplate$1(node, document) {
    const parent = document.createElement('p');
    
    const buttonDiv = document.createElement('div');
    buttonDiv.setAttribute('class', 'btn btn-accent');
    parent.appendChild(buttonDiv);
    
    const table = document.createElement('table');
    table.setAttribute('border', 0);
    table.setAttribute('cellspacing', 0);
    table.setAttribute('cellpadding', 0);
    table.setAttribute('alignment',node.getAlignment());
    buttonDiv.appendChild(table);
    
    const row = document.createElement('tr');
    table.appendChild(row);
    
    const cell = document.createElement('td');
    cell.setAttribute('align', 'center');
    row.appendChild(cell);
    
    const button = document.createElement('a');
    button.setAttribute('href', node.getButtonUrl());
    button.textContent = node.getButtonText();
    cell.appendChild(button);

    return parent;
}

function getCardClasses(node) {
    let cardClasses = ['kg-card kg-button-card'];

    if (node.getAlignment()) {
        cardClasses.push(`kg-align-${node.getAlignment()}`);
    }

    return cardClasses.join(' ');
}

const INSERT_BUTTON_COMMAND = lexical.createCommand();

class ButtonNode extends KoenigDecoratorNode {
    // payload properties
    __buttonText;
    __alignment;
    __buttonUrl;

    static getType() {
        return 'button';
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {
            buttonUrl: 'url'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            buttonText: self.__buttonText,
            alignment: self.__alignment,
            buttonUrl: self.__buttonUrl
        };
    }

    constructor({buttonText, alignment, buttonUrl} = {}, key) {
        super(key);
        this.__buttonText = buttonText || '';
        this.__alignment = alignment || 'center';
        this.__buttonUrl = buttonUrl || '';
    }

    static importJSON(serializedNode) {
        const {alignment, buttonText, buttonUrl} = serializedNode;
        const node = new this({
            alignment,
            buttonText,
            buttonUrl
        });
        return node;
    }

    exportJSON() {
        const dataset = {
            type: 'button',
            version: 1,
            buttonText: this.getButtonText(),
            alignment: this.getAlignment(),
            buttonUrl: this.getButtonUrl()
        };
        return dataset;
    }

    // parser used when pasting html >> node
    static importDOM() {
        const parser = new ButtonParser(this);
        return parser.DOMConversionMap;
    }

    // renderer used when copying node >> html
    exportDOM(options = {}) {
        const element = renderButtonNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getButtonText() {
        const self = this.getLatest();
        return self.__buttonText;
    }

    setButtonText(buttonText) {
        const writable = this.getWritable();
        return writable.__buttonText = buttonText;
    }

    getAlignment() {
        const self = this.getLatest();
        return self.__alignment;
    }

    setAlignment(alignment) {
        const writable = this.getWritable();
        return writable.__alignment = alignment;
    }

    getButtonUrl() {
        const self = this.getLatest();
        return self.__buttonUrl;
    }

    setButtonUrl(buttonUrl) {
        const writable = this.getWritable();
        return writable.__buttonUrl = buttonUrl;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }

    hasEditMode() {
        return true;
    }
}

const $createButtonNode = (dataset) => {
    return new ButtonNode(dataset);
};

function $isButtonNode(node) {
    return node instanceof ButtonNode;
}

class BookmarkParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            figure: (nodeElem) => {
                const isKgBookmarkCard = nodeElem.classList?.contains('kg-bookmark-card');
                if (nodeElem.tagName === 'FIGURE' && isKgBookmarkCard) {
                    return {
                        conversion(domNode) {
                            const url = domNode?.querySelector('.kg-bookmark-container').href;
                            const icon = domNode?.querySelector('.kg-bookmark-icon').src;
                            const title = domNode?.querySelector('.kg-bookmark-title').textContent;
                            const description = domNode?.querySelector('.kg-bookmark-description').textContent;
                            const author = domNode?.querySelector('.kg-bookmark-author').textContent;
                            const publisher = domNode?.querySelector('.kg-bookmark-publisher').textContent;
                            const thumbnail = domNode?.querySelector('.kg-bookmark-thumbnail img').src;
                            const caption = domNode?.querySelector('figure.kg-bookmark-card figcaption').textContent;
                            const payload = {
                                url: url,
                                icon: icon,
                                title: title,
                                description: description,
                                author: author,
                                publisher: publisher,
                                thumbnail: thumbnail,
                                caption: caption
                            };
                            const node = new self.NodeClass(payload);
                            return {node};
                        },
                        priority: 1
                    };
                }
                return null;
            }
        };
    }
}

// TODO: email template?

function renderBookmarkNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    if (!node.getUrl() || node.getUrl().trim() === '') {
        return document.createTextNode('');
    }

    if (options.target === 'email') {
        return emailTemplate(node);
    } else {
        return frontendTemplate(node, document);
    }
}

function emailTemplate(node) {
    const title = node.getTitle();
    const publisher = node.getPublisher();
    const author = node.getAuthor();
    const icon = node.getIcon();
    const description = node.getDescription();
    const url = node.getUrl();

    return (
        `<!--[if vml]>
            <table class="kg-card kg-bookmark-card--outlook" style="margin: 0; padding: 0; width: 100%; border: 1px solid #e5eff5; background: #ffffff; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; border-collapse: collapse; border-spacing: 0;" width="100%">
                <tr>
                    <td width="100%" style="padding: 20px;">
                        <table style="margin: 0; padding: 0; border-collapse: collapse; border-spacing: 0;">
                            <tr>
                                <td class="kg-bookmark-title--outlook">
                                    <a href="${url}" style="text-decoration: none; color: #15212A; font-size: 15px; line-height: 1.5em; font-weight: 600;">
                                        ${title}
                                    </a>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <div class="kg-bookmark-description--outlook">
                                        <a href="${url}" style="text-decoration: none; margin-top: 12px; color: #738a94; font-size: 13px; line-height: 1.5em; font-weight: 400;">
                                            ${description}
                                        </a>
                                    </div>
                                </td>
                            </tr>
                            <tr>
                                <td class="kg-bookmark-metadata--outlook" style="padding-top: 14px; color: #15212A; font-size: 13px; font-weight: 400; line-height: 1.5em;">
                                    <table style="margin: 0; padding: 0; border-collapse: collapse; border-spacing: 0;">
                                        <tr>
                                            ${icon ? `
                                                <td valign="middle" class="kg-bookmark-icon--outlook" style="padding-right: 8px; font-size: 0; line-height: 1.5em;">
                                                    <a href="${url}" style="text-decoration: none; color: #15212A;">
                                                        <img src="${icon}" width="22" height="22" alt=" ">
                                                    </a>
                                                </td>
                                            ` : ''}
                                            <td valign="middle" class="kg-bookmark-byline--outlook">
                                                <a href="${url}" style="text-decoration: none; color: #15212A;">
                                                    ${publisher}
                                                    ${author ? `&nbsp;&#x2022;&nbsp;` : ''}
                                                    ${author}
                                                </a>
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                            </tr>
                        </table>
                    </td>
                </tr>
            </table>
            <div class="kg-bookmark-spacer--outlook" style="height: 1.5em;">&nbsp;</div>
        <![endif]-->`
    );
}

function frontendTemplate(node, document) {
    const card = document.createElement('figure');
    const caption = node.getCaption();
    let cardClass = 'kg-card kg-bookmark-card';
    if (caption) {
        cardClass += ' kg-card-hascaption';
    }
    card.setAttribute('class', cardClass);

    const container = document.createElement('a');
    container.setAttribute('class','kg-bookmark-container');
    container.href = node.getUrl();
    card.appendChild(container);

    const content = document.createElement('div');
    content.setAttribute('class','kg-bookmark-content');
    container.appendChild(content);

    const title = document.createElement('div');
    title.setAttribute('class','kg-bookmark-title');
    title.textContent = node.getTitle();
    content.appendChild(title);

    const description = document.createElement('div');
    description.setAttribute('class','kg-bookmark-description');
    description.textContent = node.getDescription();
    content.appendChild(description);

    const metadata = document.createElement('div');
    metadata.setAttribute('class','kg-bookmark-metadata');
    content.appendChild(metadata);

    metadata.icon = node.getIcon();
    if (metadata.icon) {
        const icon = document.createElement('img');
        icon.setAttribute('class','kg-bookmark-icon');
        icon.src = metadata.icon;
        icon.alt = '';
        metadata.appendChild(icon);
    }

    metadata.author = node.getAuthor();
    if (metadata.author) {
        const author = document.createElement('span');
        author.setAttribute('class','kg-bookmark-author');
        author.textContent = metadata.author;
        metadata.appendChild(author);
    }

    metadata.publisher = node.getPublisher();
    if (metadata.publisher) {
        const publisher = document.createElement('span');
        publisher.setAttribute('class','kg-bookmark-publisher');
        publisher.textContent = metadata.publisher;
        metadata.appendChild(publisher);
    }

    metadata.thumbnail = node.getThumbnail();
    if (metadata.thumbnail) {
        const thumbnailDiv = document.createElement('div');
        thumbnailDiv.setAttribute('class','kg-bookmark-thumbnail');
        container.appendChild(thumbnailDiv);

        const thumbnail = document.createElement('img');
        thumbnail.src = metadata.thumbnail;
        thumbnail.alt = '';
        thumbnailDiv.appendChild(thumbnail);
    }

    if (caption) {
        const figCaption = document.createElement('figcaption');
        figCaption.textContent = caption;
        card.appendChild(figCaption);
    }

    return card;
}

const INSERT_BOOKMARK_COMMAND = lexical.createCommand();

class BookmarkNode extends KoenigDecoratorNode {
    // payload properties
    __url;
    __icon;
    __title;
    __description;
    __author;
    __publisher;
    __thumbnail;
    __caption;

    static getType() {
        return 'bookmark';
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {
            url: 'url',
            icon: 'url',
            thumbnail: 'url'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            url: self.__url,
            icon: self.__icon,
            title: self.__title,
            description: self.__description,
            author: self.__author,
            publisher: self.__publisher,
            thumbnail: self.__thumbnail,
            caption: self.__caption
        
        };
    }

    constructor({url, icon, title, description, author, publisher, thumbnail, caption} = {}, key) {
        super(key);
        this.__url = url || '';
        this.__icon = icon || '';
        this.__title = title || '';
        this.__description = description || '';
        this.__author = author || '';
        this.__publisher = publisher || '';
        this.__thumbnail = thumbnail || '';
        this.__caption = caption || '';
    }

    static importJSON(serializedNode) {
        const {url, icon, title, description, author, publisher, thumbnail, caption} = serializedNode;
        const node = new this({
            url,
            icon,
            title,
            description,
            author,
            publisher, 
            thumbnail,
            caption
        });
        return node;
    }

    exportJSON() {
        const dataset = {
            type: 'bookmark',
            version: 1,
            url: this.getUrl(),
            icon: this.getIcon(),
            title: this.getTitle(),
            description: this.getDescription(),
            author: this.getAuthor(),
            publisher: this.getPublisher(),
            thumbnail: this.getThumbnail(),
            caption: this.getCaption()
        };
        return dataset;
    }

    // parser used when pasting html >> node
    static importDOM() {
        const parser = new BookmarkParser(this);
        return parser.DOMConversionMap;
    }

    // renderer used when copying node >> html
    exportDOM(options = {}) {
        const element = renderBookmarkNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getUrl() {
        const self = this.getLatest();
        return self.__url;
    }

    setUrl(url) {
        const writable = this.getWritable();
        return writable.__url = url;
    }

    getIcon() {
        const self = this.getLatest();
        return self.__icon;
    }

    setIcon(icon) {
        const writable = this.getWritable();
        return writable.__icon = icon;
    }

    getTitle() {
        const self = this.getLatest();
        return self.__title;
    }

    setTitle(title) {
        const writable = this.getWritable();
        return writable.__title = title;
    }
    
    getDescription() {
        const self = this.getLatest();
        return self.__description;
    }

    setDescription(description) {
        const writable = this.getWritable();
        return writable.__description = description;
    }

    getAuthor() {
        const self = this.getLatest();
        return self.__author;
    }

    setAuthor(author) {
        const writable = this.getWritable();
        return writable.__author = author;
    }

    getPublisher() {
        const self = this.getLatest();
        return self.__publisher;
    }

    setPublisher(publisher) {
        const writable = this.getWritable();
        return writable.__publisher = publisher;
    }

    getThumbnail() {
        const self = this.getLatest();
        return self.__thumbnail;
    }

    setThumbnail(thumbnail) {
        const writable = this.getWritable();
        return writable.__thumbnail = thumbnail;
    }

    getCaption() {
        const self = this.getLatest();
        return self.__caption;
    }

    setCaption(caption) {
        const writable = this.getWritable();
        return writable.__caption = caption;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        return !this.__url;
    }
}

const $createBookmarkNode = (dataset) => {
    return new BookmarkNode(dataset);
};

function $isBookmarkNode(node) {
    return node instanceof BookmarkNode;
}

function renderFileNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);
  
    const document = options.createDocument();
  
    if (!node.getSrc() || node.getSrc().trim() === '') {
        return document.createTextNode('');
    }
  
    const card = document.createElement('div');
    card.setAttribute('class', 'kg-card kg-file-card');
  
    const container = document.createElement('a');
    container.setAttribute('class', 'kg-file-card-container');
    container.setAttribute('href', node.getSrc());
    container.setAttribute('title', 'Download');
    container.setAttribute('download', '');
  
    const contents = document.createElement('div');
    contents.setAttribute('class', 'kg-file-card-contents');
  
    const title = document.createElement('div');
    title.setAttribute('class', 'kg-file-card-title');
    title.textContent = node.getTitle() || '';
  
    const caption = document.createElement('div');
    caption.setAttribute('class', 'kg-file-card-caption');
    caption.textContent = node.getDescription() || '';
  
    const metadata = document.createElement('div');
    metadata.setAttribute('class', 'kg-file-card-metadata');
  
    const filename = document.createElement('div');
    filename.setAttribute('class', 'kg-file-card-filename');
    filename.textContent = node.getFileName() || '';
  
    const filesize = document.createElement('div');
    filesize.setAttribute('class', 'kg-file-card-filesize');
    filesize.textContent = node.getFileSize() || '';
  
    metadata.appendChild(filename);
    metadata.appendChild(filesize);
  
    contents.appendChild(title);
    contents.appendChild(caption);
    contents.appendChild(metadata);
  
    container.appendChild(contents);
  
    const icon = document.createElement('div');
    icon.setAttribute('class', 'kg-file-card-icon');
  
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('viewBox', '0 0 24 24');
  
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
  
    const style = document.createElementNS('http://www.w3.org/2000/svg', 'style');
    style.textContent = '.a{fill:none;stroke:currentColor;stroke-linecap:round;stroke-linejoin:round;stroke-width:1.5px;}';
  
    defs.appendChild(style);
  
    const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'title');
    titleElement.textContent = 'download-circle';
  
    const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
    polyline.setAttribute('class', 'a');
    polyline.setAttribute('points', '8.25 14.25 12 18 15.75 14.25');
  
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('class', 'a');
    line.setAttribute('x1', '12');
    line.setAttribute('y1', '6.75');
    line.setAttribute('x2', '12');
    line.setAttribute('y2', '18');
  
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('class', 'a');
    circle.setAttribute('cx', '12');
    circle.setAttribute('cy', '12');
    circle.setAttribute('r', '11.25');
  
    svg.appendChild(defs);
    svg.appendChild(titleElement);
    svg.appendChild(polyline);
    svg.appendChild(line);
    svg.appendChild(circle);
  
    icon.appendChild(svg);
  
    container.appendChild(icon);
  
    card.appendChild(container);
  
    return card;
}

class FileParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            div: (nodeElem) => {
                const isKgFileCard = nodeElem.classList?.contains('kg-file-card');
                if (nodeElem.tagName === 'DIV' && isKgFileCard) {
                    return {
                        conversion(domNode) {
                            const link = domNode.querySelector('a');
                            const src = link.getAttribute('href');
                            const title = domNode.querySelector('.kg-file-card-title')?.textContent || '';
                            const description = domNode.querySelector('.kg-file-card-caption')?.textContent || '';
                            const fileName = domNode.querySelector('.kg-file-card-filename')?.textContent || '';
                            let fileSize = domNode.querySelector('.kg-file-card-filesize')?.textContent || '';
                            const payload = {
                                src,
                                title,
                                description,
                                fileName,
                                fileSize
                            };

                            const node = new self.NodeClass(payload);
                            return {node};
                        },
                        priority: 1
                    };
                }
                return null;
            }
        };
    }
}

const INSERT_FILE_COMMAND = lexical.createCommand();

function bytesToSize(bytes) {
    if (!bytes) {
        return '0 Byte';
    }
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    if (bytes === 0) {
        return '0 Byte';
    }
    const i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
    return Math.round((bytes / Math.pow(1024, i))) + ' ' + sizes[i];
}

class FileNode extends KoenigDecoratorNode {
    // file payload properties
    __src;
    __title;
    __description;
    __fileName;
    __fileSize;

    static getType() {
        return 'file';
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    static get urlTransformMap() {
        return {
            src: 'url'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            src: self.__src,
            title: self.__title,
            description: self.__description,
            fileName: self.__fileName,
            fileSize: self.__fileSize
        };
    }

    constructor({src, title, description, fileName, fileSize} = {}, key) {
        super(key);
        this.__src = src || '';
        this.__title = title || '';
        this.__description = description || '';
        this.__fileName = fileName || '';
        this.__fileSize = fileSize || '';
    }

    static importJSON(serializedNode) {
        const {src, title, description, fileName, fileSize} = serializedNode;
        return new this({
            src,
            title,
            description,
            fileName,
            fileSize
        });
    }

    exportJSON() {
        const src = this.getSrc();
        const isBlob = src.startsWith('data:');
        return {
            type: this.getType(),
            src: isBlob ? '<base64String>' : this.getSrc(),
            title: this.__title,
            description: this.__description,
            fileName: this.__fileName,
            fileSize: this.__fileSize
        };
    }

    static importDOM() {
        const parser = new FileParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderFileNodeToDOM(this, options);
        return {element};
    }

    // c8 ignore start
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }

    getSrc() {
        const self = this.getLatest();
        return self.__src;
    }

    setSrc(src) {
        const writable = this.getWritable();
        writable.__src = src;
    }

    getTitle() {
        const self = this.getLatest();
        return self.__title;
    }

    setTitle(title) {
        const writable = this.getWritable();
        writable.__title = title;
    }

    getDescription() {
        const self = this.getLatest();
        return self.__description;
    }

    setDescription(description) {
        const writable = this.getWritable();
        writable.__description = description;
    }

    getFileName() {
        const self = this.getLatest();
        return self.__fileName;
    }

    setFileName(fileName) {
        const writable = this.getWritable();
        writable.__fileName = fileName;
    }

    getFileSize() {
        const self = this.getLatest();
        return self.__fileSize;
    }

    setFileSize(fileSize) {
        const writable = this.getWritable();
        const size = bytesToSize(fileSize);
        writable.__fileSize = size;
    }

    hasEditMode() {
        return true;
    }
    // c8 ignore stop
    decorate() {
        return '';
    }
}

function $isFileNode(node) {
    return node instanceof FileNode;
}

const $createFileNode = (dataset) => {
    return new FileNode(dataset);
};

class PaywallParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            '#comment': () => {
                return {
                    conversion(domNode) {
                        const isCommentNode = domNode.nodeType === 8;
                        if (isCommentNode && domNode.nodeValue.trim() === 'members-only') {
                            const node = new self.NodeClass();
                            return {node};
                        }

                        return null;
                    },
                    priority: 0
                };
            }
        };
    }
}

function renderPaywallNodeToDOM(_, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();
    const div = document.createElement('div');

    div.innerHTML = '<!--members-only-->';

    return div;
}

const INSERT_PAYWALL_COMMAND = lexical.createCommand();
const NODE_TYPE$2 = 'paywall';

class PaywallNode extends KoenigDecoratorNode {
    static getType() {
        return NODE_TYPE$2;
    }

    static clone(node) {
        return new this(
            node.__key
        );
    }

    static get urlTransformMap() {
        return {};
    }

    constructor(key) {
        super(key);
    }

    static importJSON() {
        const node = new this();
        return node;
    }

    exportJSON() {
        const dataset = {
            type: NODE_TYPE$2,
            version: 1
        };
        return dataset;
    }

    static importDOM() {
        const parser = new PaywallParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderPaywallNodeToDOM(this, options);
        return {element, type: 'inner'};
    }

    /* c8 ignore start */
    createDOM() {
        return document.createElement('div');
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }
}

const $createPaywallNode = (dataset) => {
    return new PaywallNode(dataset);
};

function $isPaywallNode(node) {
    return node instanceof PaywallNode;
}

class ProductParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            div: () => ({
                conversion(domNode) {
                    const isKgProductCard = domNode.classList?.contains('kg-product-card');
                    if (domNode.tagName === 'DIV' && isKgProductCard) {
                        const title = readCaptionFromElement(domNode, {selector: '.kg-product-card-title'});
                        const description = readCaptionFromElement(domNode, {selector: '.kg-product-card-description'});

                        const payload = {
                            isButtonEnabled: false,
                            isRatingEnabled: false,
                            title: title,
                            description: description
                        };

                        const img = domNode.querySelector('.kg-product-card-image');
                        if (img && img.getAttribute('src')) {
                            payload.imgSrc = img.getAttribute('src');

                            if (img.getAttribute('width')) {
                                payload.imgWidth = img.getAttribute('width');
                            }

                            if (img.getAttribute('height')) {
                                payload.imgHeight = img.getAttribute('height');
                            }
                        }

                        const stars = [...domNode.querySelectorAll('.kg-product-card-rating-active')].length;
                        if (stars) {
                            payload.isRatingEnabled = true;
                            payload.starRating = stars;
                        }

                        const button = domNode.querySelector('a');

                        if (button) {
                            const buttonUrl = button.href;
                            const buttonText = getButtonText(button);

                            if (buttonUrl && buttonText) {
                                payload.isButtonEnabled = true;
                                payload.buttonText = buttonText;
                                payload.buttonUrl = buttonUrl;
                            }
                        }

                        if (!title && !description && !img && !button) {
                            return null;
                        }

                        const node = new self.NodeClass(payload);
                        return {node};
                    }

                    return null;
                },
                priority: 1
            })
        };
    }
}

function getButtonText(node) {
    let buttonText = node.textContent;
    if (buttonText) {
        buttonText = buttonText.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
    }
    return buttonText;
}

function renderProductNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    if (node.isEmpty()) {
        return document.createTextNode('');
    }

    const templateData = {
        ...node.getDataset(),
        starIcon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12.729,1.2l3.346,6.629,6.44.638a.805.805,0,0,1,.5,1.374l-5.3,5.253,1.965,7.138a.813.813,0,0,1-1.151.935L12,19.934,5.48,23.163a.813.813,0,0,1-1.151-.935L6.294,15.09.99,9.837a.805.805,0,0,1,.5-1.374l6.44-.638L11.271,1.2A.819.819,0,0,1,12.729,1.2Z"/></svg>`
    };

    const starActiveClasses = 'kg-product-card-rating-active';
    for (let i = 1; i <= 5; i++) {
        templateData['star' + i] = '';
        if (node.getStarRating() >= i) {
            templateData['star' + i] = starActiveClasses;
        }
    }

    const htmlString = options.target === 'email'
        ? emailCardTemplate({data: templateData})
        : cardTemplate({data: templateData});

    const element = document.createElement('div');
    element.innerHTML = htmlString.trim();

    return element.firstElementChild;
}

function cardTemplate({data}) {
    return (
        `
        <div class="kg-card kg-product-card">
            <div class="kg-product-card-container">
                ${data.imgSrc ? `<img src="${data.imgSrc}" ${data.imgWidth ? `width="${data.imgWidth}"` : ''} ${data.imgHeight ? `height="${data.imgHeight}"` : ''} class="kg-product-card-image" loading="lazy" />` : ''}
                <div class="kg-product-card-title-container">
                    <h4 class="kg-product-card-title">${data.title}</h4>
                </div>
                ${data.isRatingEnabled ? `
                    <div class="kg-product-card-rating">
                        <span class="${data.star1} kg-product-card-rating-star">${data.starIcon}</span>
                        <span class="${data.star2} kg-product-card-rating-star">${data.starIcon}</span>
                        <span class="${data.star3} kg-product-card-rating-star">${data.starIcon}</span>
                        <span class="${data.star4} kg-product-card-rating-star">${data.starIcon}</span>
                        <span class="${data.star5} kg-product-card-rating-star">${data.starIcon}</span>
                    </div>
                ` : ''}

                <div class="kg-product-card-description">${data.description}</div>
                ${data.isButtonEnabled ? `
                    <a href="${data.buttonUrl}" class="kg-product-card-button kg-product-card-btn-accent" target="_blank" rel="noopener noreferrer"><span>${data.buttonText}</span></a>
                ` : ''}
            </div>
        </div>
    `
    );
}

function emailCardTemplate({data}) {
    return (
        `
         <table cellspacing="0" cellpadding="0" border="0" style="width:100%; padding:20px; border:1px solid #E9E9E9; border-radius: 5px; margin: 0 0 1.5em; width: 100%;">
            ${data.imgSrc ? `
                <tr>
                    <td align="center" style="padding-top:0; padding-bottom:0; margin-bottom:0; padding-bottom:0;">
                        <img src="${data.imgSrc}" ${data.imgWidth ? `width="${data.imgWidth}"` : ''} ${data.imgHeight ? `height="${data.imgHeight}"` : ''} style="height: auto; border: none; padding-bottom: 16px;" border="0">
                    </td>
                </tr>
            ` : ''}
            <tr>
                <td valign="top">
                    <h4 style="font-size: 22px !important; margin-top: 0 !important; margin-bottom: 0 !important; font-weight: 700;">${data.title}</h4>
                </td>
            </tr>
            ${data.isRatingEnabled ? `
                <tr style="padding-top:0; padding-bottom:0; margin-bottom:0; padding-bottom:0;">
                    <td valign="top">
                        <img src="${`https://static.ghost.org/v4.0.0/images/star-rating-${data.starRating}.png`}" style="border: none; width: 96px;" border="0">
                    </td>
                </tr>
            ` : ''}
            <tr>
                <td style="padding-top:0; padding-bottom:0; margin-bottom:0; padding-bottom:0;">
                    <div style="padding-top: 8px; opacity: 0.7; font-size: 17px; line-height: 1.4; margin-bottom: -24px;">${data.description}</div>
                </td>
            </tr>
            ${data.isButtonEnabled ? `
                <tr>
                    <td style="padding-top:0; padding-bottom:0; margin-bottom:0; padding-bottom:0;">
                        <div class="btn btn-accent" style="box-sizing: border-box;display: table;width: 100%;padding-top: 16px;">
                            <a href="${data.buttonUrl}" style="overflow-wrap: anywhere;border: solid 1px;border-radius: 5px;box-sizing: border-box;cursor: pointer;display: inline-block;font-size: 14px;font-weight: bold;margin: 0;padding: 12px 25px;text-decoration: none;color: #FFFFFF; width: 100%; text-align: center;">${data.buttonText}</a>
                        </div>
                    </td>
                </tr>
            ` : ''}
        </table>
        `
    );
}

const INSERT_PRODUCT_COMMAND = lexical.createCommand();
const NODE_TYPE$1 = 'product';

class ProductNode extends KoenigDecoratorNode {
    // payload properties
    __imgSrc;
    __imgWidth;
    __imgHeight;
    __title;
    __description;
    __isRatingEnabled;
    __starRating;
    __isButtonEnabled;
    __buttonText;
    __buttonUrl;

    static getType() {
        return NODE_TYPE$1;
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {
            imgSrc: 'url',
            title: 'html',
            description: 'html'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            imgSrc: self.__imgSrc,
            imgWidth: self.__imgWidth,
            imgHeight: self.__imgHeight,
            title: self.__title,
            description: self.__description,
            isRatingEnabled: self.__isRatingEnabled,
            starRating: self.__starRating,
            isButtonEnabled: self.__isButtonEnabled,
            buttonText: self.__buttonText,
            buttonUrl: self.__buttonUrl
        };
    }

    constructor({imgSrc, imgWidth, imgHeight, title, description, isRatingEnabled, starRating, isButtonEnabled, buttonText, buttonUrl} = {}, key) {
        super(key);
        this.__imgSrc = imgSrc || '';
        this.__imgWidth = imgWidth || null;
        this.__imgHeight = imgHeight || null;
        this.__title = title || '';
        this.__description = description || '';
        this.__isRatingEnabled = !!isRatingEnabled;
        this.__starRating = starRating || 5;
        this.__isButtonEnabled = !!isButtonEnabled;
        this.__buttonText = buttonText || '';
        this.__buttonUrl = buttonUrl || '';
    }

    static importJSON(serializedNode) {
        const {imgSrc, imgWidth, imgHeight, title, description, isRatingEnabled, starRating, isButtonEnabled, buttonText, buttonUrl} = serializedNode;
        const node = new this({
            imgSrc,
            imgWidth,
            imgHeight,
            title,
            description,
            isRatingEnabled,
            starRating,
            isButtonEnabled,
            buttonText,
            buttonUrl
        });
        return node;
    }

    exportJSON() {
        // checks if src is a data string
        const src = this.getImgSrc();
        const isBlob = src.startsWith('data:');
        const dataset = {
            type: NODE_TYPE$1,
            version: 1,
            imgSrc: isBlob ? '<base64String>' : this.getImgSrc(),
            imgWidth: this.getImgWidth(),
            imgHeight: this.getImgHeight(),
            title: this.getTitle(),
            description: this.getDescription(),
            isRatingEnabled: this.getIsRatingEnabled(),
            starRating: this.getStarRating(),
            isButtonEnabled: this.getIsButtonEnabled(),
            buttonText: this.getButtonText(),
            buttonUrl: this.getButtonUrl()

        };
        return dataset;
    }

    static importDOM() {
        const parser = new ProductParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderProductNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getImgSrc() {
        const self = this.getLatest();
        return self.__imgSrc;
    }

    setImgSrc(imgSrc) {
        const writable = this.getWritable();
        return writable.__imgSrc = imgSrc;
    }

    getImgWidth() {
        const self = this.getLatest();
        return self.__imgWidth;
    }

    setImgWidth(imgWidth) {
        const writable = this.getWritable();
        return writable.__imgWidth = imgWidth;
    }

    getImgHeight() {
        const self = this.getLatest();
        return self.__imgHeight;
    }

    setImgHeight(imgHeight) {
        const writable = this.getWritable();
        return writable.__imgHeight = imgHeight;
    }

    getTitle() {
        const self = this.getLatest();
        return self.__title;
    }

    setTitle(title) {
        const writable = this.getWritable();
        return writable.__title = title;
    }

    getDescription() {
        const self = this.getLatest();
        return self.__description;
    }

    setDescription(description) {
        const writable = this.getWritable();
        return writable.__description = description;
    }

    getIsRatingEnabled() {
        const self = this.getLatest();
        return self.__isRatingEnabled;
    }

    setIsRatingEnabled(isRatingEnabled) {
        const writable = this.getWritable();
        return writable.__isRatingEnabled = isRatingEnabled;
    }

    getStarRating() {
        const self = this.getLatest();
        return self.__starRating;
    }

    setStarRating(starRating) {
        const writable = this.getWritable();
        return writable.__starRating = starRating;
    }

    getIsButtonEnabled() {
        const self = this.getLatest();
        return self.__isButtonEnabled;
    }

    setIsButtonEnabled(isButtonEnabled) {
        const writable = this.getWritable();
        return writable.__isButtonEnabled = isButtonEnabled;
    }

    getButtonText() {
        const self = this.getLatest();
        return self.__buttonText;
    }

    setButtonText(buttonText) {
        const writable = this.getWritable();
        return writable.__buttonText = buttonText;
    }

    getButtonUrl() {
        const self = this.getLatest();
        return self.__buttonUrl;
    }

    setButtonUrl(buttonUrl) {
        const writable = this.getWritable();
        return writable.__buttonUrl = buttonUrl;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        const isButtonFilled = this.__isButtonEnabled && this.__buttonUrl && this.__buttonText;
        return !this.__title && !this.__description && !isButtonFilled && !this.__imgSrc && !this.__isRatingEnabled;
    }
}

const $createProductNode = (dataset) => {
    return new ProductNode(dataset);
};

function $isProductNode(node) {
    return node instanceof ProductNode;
}

class EmbedParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        // const self = this;

        return {
            // figure: (nodeElem) => {
            //     const isKgEmbedCard = nodeElem.classList?.contains('kg-embed-card');
            //     if (nodeElem.tagName === 'FIGURE' && isKgEmbedCard) {
            //         return {
            //             conversion(domNode) {
            //                 const url = domNode?.querySelector('.kg-embed-container').href;
            //                 const icon = domNode?.querySelector('.kg-embed-icon').src;
            //                 const title = domNode?.querySelector('.kg-embed-title').textContent;
            //                 const description = domNode?.querySelector('.kg-embed-description').textContent;
            //                 const author = domNode?.querySelector('.kg-embed-author').textContent;
            //                 const publisher = domNode?.querySelector('.kg-embed-publisher').textContent;
            //                 const thumbnail = domNode?.querySelector('.kg-embed-thumbnail img').src;
            //                 const caption = domNode?.querySelector('figure.kg-embed-card figcaption').textContent;
            //                 const payload = {
            //                     url: url,
            //                     icon: icon,
            //                     title: title,
            //                     description: description,
            //                     author: author,
            //                     publisher: publisher,
            //                     thumbnail: thumbnail,
            //                     caption: caption
            //                 };
            //                 const node = new self.NodeClass(payload);
            //                 return {node};
            //             },
            //             priority: 1
            //         };
            //     }
            //     return null;
            // }
        };
    }
}

// const nftCard = require('./types/nft');
// const twitterCard = require('./types/twitter');

function renderEmbedNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();
    const embedType = node.getEmbedType();
    // const metadata = node.getMetadata();

    if (!node.getHtml() && embedType !== 'nft') {
        return document.createTextNode('');
    }

    // if (embedType === 'twitter') {
    //     return twitterCard.render(node, document, options);
    // }

    // if (metadata && embedType === 'nft') {
    //     return nftCard.render(node, document, options);
    // }

    return renderTemplate(node, document, options);
}

function renderTemplate(node, document, options) {
    const isEmail = options.target === 'email';
    const metadata = node.getMetadata();
    const url = node.getUrl();
    const isVideoWithThumbnail = node.getType() === 'video' && metadata && metadata.thumbnail_url;

    const figure = document.createElement('figure');
    figure.setAttribute('class', 'kg-card kg-embed-card');
    const container = document.createElement('div');

    if (isEmail && isVideoWithThumbnail) {
        const emailTemplateMaxWidth = 600;
        const thumbnailAspectRatio = metadata.thumbnail_width / metadata.thumbnail_height;
        const spacerWidth = Math.round(emailTemplateMaxWidth / 4);
        const spacerHeight = Math.round(emailTemplateMaxWidth / thumbnailAspectRatio);
        const html = `
            <!--[if !mso !vml]-->
            <a class="kg-video-preview" href="${url}" aria-label="Play video" style="mso-hide: all">
                <table cellpadding="0" cellspacing="0" border="0" width="100%" background="${metadata.thumbnail_url}" role="presentation" style="background: url('${metadata.thumbnail_url}') left top / cover; mso-hide: all">
                    <tr style="mso-hide: all">
                        <td width="25%" style="visibility: hidden; mso-hide: all">
                            <img src="https://img.spacergif.org/v1/${spacerWidth}x${spacerHeight}/0a/spacer.png" alt="" width="100%" border="0" style="height: auto; opacity: 0; visibility: hidden; mso-hide: all;">
                        </td>
                        <td width="50%" align="center" valign="middle" style="vertical-align: middle; mso-hide: all;">
                            <div class="kg-video-play-button" style="mso-hide: all"><div style="mso-hide: all"></div></div>
                        </td>
                        <td width="25%" style="mso-hide: all">&nbsp;</td>
                    </tr>
                </table>
            </a>
            <!--[endif]-->

            <!--[if vml]>
            <v:group xmlns:v="urn:schemas-microsoft-com:vml" xmlns:w="urn:schemas-microsoft-com:office:word" coordsize="${emailTemplateMaxWidth},${spacerHeight}" coordorigin="0,0" href="${url}" style="width:${emailTemplateMaxWidth}px;height:${spacerHeight}px;">
                <v:rect fill="t" stroked="f" style="position:absolute;width:${emailTemplateMaxWidth};height:${spacerHeight};"><v:fill src="${metadata.thumbnail_url}" type="frame"/></v:rect>
                <v:oval fill="t" strokecolor="white" strokeweight="4px" style="position:absolute;left:${Math.round((emailTemplateMaxWidth / 2) - 39)};top:${Math.round((spacerHeight / 2) - 39)};width:78;height:78"><v:fill color="black" opacity="30%" /></v:oval>
                <v:shape coordsize="24,32" path="m,l,32,24,16,xe" fillcolor="white" stroked="f" style="position:absolute;left:${Math.round((emailTemplateMaxWidth / 2) - 11)};top:${Math.round((spacerHeight / 2) - 17)};width:30;height:34;" />
            </v:group>
            <![endif]-->
        `;
        container.innerHTML = html.trim();
        figure.appendChild(container);
    } else {
        container.innerHTML = node.getHtml();
        figure.appendChild(container);
    }
    
    const caption = node.getCaption();
    if (caption) {
        const figcaption = document.createElement('figcaption');
        figcaption.textContent = caption;
        figure.appendChild(figcaption);
        figure.setAttribute('class', `${figure.getAttribute('class')} kg-card-hascaption`);
    }

    return figure;
}

const INSERT_EMBED_COMMAND = lexical.createCommand();

class EmbedNode extends KoenigDecoratorNode {
    // payload properties
    __url;
    __embedType;
    __html;
    __metadata;
    __caption;

    static getType() {
        return 'embed';
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {
            url: 'url'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            url: self.__url,
            embedType: self.__embedType,
            html: self.__html,
            metadata: self.__metadata,
            caption: self.__caption
        };
    }

    constructor({url, embedType, html, metadata, caption} = {}, key) {
        super(key);
        this.__url = url || '';
        this.__embedType = embedType || '';
        this.__html = html || '';
        this.__metadata = metadata || {};
        this.__caption = caption || '';
    }

    static importJSON(serializedNode) {
        const {url, embedType, html, metadata, caption} = serializedNode;
        const node = new this({
            url,
            embedType,
            html,
            metadata,
            caption
        });
        return node;
    }

    exportJSON() {
        const dataset = {
            type: 'embed',
            version: 1,
            url: this.getUrl(),
            embedType: this.getEmbedType(),
            html: this.getHtml(),
            metadata: this.getMetadata(),
            caption: this.getCaption()
        };
        return dataset;
    }

    // parser used when pasting html >> node
    static importDOM() {
        const parser = new EmbedParser(this);
        return parser.DOMConversionMap;
    }

    // renderer used when copying node >> html
    exportDOM(options = {}) {
        const element = renderEmbedNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getUrl() {
        const self = this.getLatest();
        return self.__url;
    }

    setUrl(url) {
        const writable = this.getWritable();
        return writable.__url = url;
    }

    getEmbedType() {
        const self = this.getLatest();
        return self.__embedType;
    }

    setEmbedType(type) {
        const writable = this.getWritable();
        return writable.__embedType = type;
    }

    getHtml() {
        const self = this.getLatest();
        return self.__html;
    }

    setHtml(html) {
        const writable = this.getWritable();
        return writable.__html = html;
    }

    getMetadata() {
        const self = this.getLatest();
        return self.__metadata;
    }

    setMetadata(metadata) {
        const writable = this.getWritable();
        return writable.__metadata = metadata;
    }

    getCaption() {
        const self = this.getLatest();
        return self.__caption;
    }

    setCaption(caption) {
        const writable = this.getWritable();
        return writable.__caption = caption;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        return !this.__url;
    }
}

const $createEmbedNode = (dataset) => {
    return new EmbedNode(dataset);
};

function $isEmbedNode(node) {
    return node instanceof EmbedNode;
}

/**
 * Removes consecutive whitespaces and newlines
 * @param {string} html
 * @returns {string}
 */
function removeSpaces(html) {
    return html.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
}

/**
 * Wraps replacement strings with %%
 * This helps to prevent conflicts between code samples and our replacement strings
 * Example: {foo} -> %%{foo}%%
 * @param {string} html
 * @returns {string}
 */
function wrapReplacementStrings(html) {
    return html.replace(/\{(\w*?)(?:,? *"(.*?)")?\}/g, '%%$&%%');
}

function renderEmailNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);
    const document = options.createDocument();

    const html = node.getHtml();

    if (!html || options.target !== 'email') {
        return document.createTextNode('');
    }

    const cleanedHtml = wrapReplacementStrings(removeSpaces(html));
    const div = document.createElement('div');
    div.innerHTML = cleanedHtml;

    return div;
}

const INSERT_EMAIL_COMMAND = lexical.createCommand();
const NODE_TYPE = 'email';

class EmailNode extends KoenigDecoratorNode {
    // payload properties
    __html;

    static getType() {
        return NODE_TYPE;
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    static get urlTransformMap() {
        return {
            html: 'html'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            html: self.__html
        };
    }

    constructor({html} = {}, key) {
        super(key);
        this.__html = html || '';
    }

    static importJSON(serializedNode) {
        const {html} = serializedNode;
        return new this({
            html
        });
    }

    exportJSON() {
        const dataset = {
            type: NODE_TYPE,
            version: 1,
            html: this.getHtml()
        };
        return dataset;
    }

    exportDOM(options = {}) {
        const element = renderEmailNodeToDOM(this, options);
        return {element, type: 'inner'};
    }

    /* c8 ignore start */
    createDOM() {
        return document.createElement('div');
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getHtml() {
        const self = this.getLatest();
        return self.__html;
    }

    setHtml(html) {
        const writable = this.getWritable();
        return writable.__html = html;
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        return !this.__html;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }
}

const $createEmailNode = (dataset) => {
    return new EmailNode(dataset);
};

function $isEmailNode(node) {
    return node instanceof EmailNode;
}

// export convenience objects for use elsewhere
const DEFAULT_NODES = [
    CodeBlockNode,
    ImageNode,
    MarkdownNode,
    VideoNode,
    AudioNode,
    CalloutNode,
    AsideNode,
    HorizontalRuleNode,
    HtmlNode,
    FileNode,
    ToggleNode,
    ButtonNode,
    BookmarkNode,
    PaywallNode,
    ProductNode,
    EmbedNode,
    EmailNode
];

exports.$createAsideNode = $createAsideNode;
exports.$createAudioNode = $createAudioNode;
exports.$createBookmarkNode = $createBookmarkNode;
exports.$createButtonNode = $createButtonNode;
exports.$createCalloutNode = $createCalloutNode;
exports.$createCodeBlockNode = $createCodeBlockNode;
exports.$createEmailNode = $createEmailNode;
exports.$createEmbedNode = $createEmbedNode;
exports.$createFileNode = $createFileNode;
exports.$createHorizontalRuleNode = $createHorizontalRuleNode;
exports.$createHtmlNode = $createHtmlNode;
exports.$createImageNode = $createImageNode;
exports.$createMarkdownNode = $createMarkdownNode;
exports.$createPaywallNode = $createPaywallNode;
exports.$createProductNode = $createProductNode;
exports.$createToggleNode = $createToggleNode;
exports.$createVideoNode = $createVideoNode;
exports.$isAsideNode = $isAsideNode;
exports.$isAudioNode = $isAudioNode;
exports.$isBookmarkNode = $isBookmarkNode;
exports.$isButtonNode = $isButtonNode;
exports.$isCalloutNode = $isCalloutNode;
exports.$isCodeBlockNode = $isCodeBlockNode;
exports.$isEmailNode = $isEmailNode;
exports.$isEmbedNode = $isEmbedNode;
exports.$isFileNode = $isFileNode;
exports.$isHorizontalRuleNode = $isHorizontalRuleNode;
exports.$isHtmlNode = $isHtmlNode;
exports.$isImageNode = $isImageNode;
exports.$isKoenigCard = $isKoenigCard;
exports.$isMarkdownNode = $isMarkdownNode;
exports.$isPaywallNode = $isPaywallNode;
exports.$isProductNode = $isProductNode;
exports.$isToggleNode = $isToggleNode;
exports.$isVideoNode = $isVideoNode;
exports.AsideNode = AsideNode;
exports.AudioNode = AudioNode;
exports.BookmarkNode = BookmarkNode;
exports.ButtonNode = ButtonNode;
exports.CalloutNode = CalloutNode;
exports.CodeBlockNode = CodeBlockNode;
exports.DEFAULT_NODES = DEFAULT_NODES;
exports.EmailNode = EmailNode;
exports.EmbedNode = EmbedNode;
exports.FileNode = FileNode;
exports.HorizontalRuleNode = HorizontalRuleNode;
exports.HtmlNode = HtmlNode;
exports.INSERT_AUDIO_COMMAND = INSERT_AUDIO_COMMAND;
exports.INSERT_BOOKMARK_COMMAND = INSERT_BOOKMARK_COMMAND;
exports.INSERT_BUTTON_COMMAND = INSERT_BUTTON_COMMAND;
exports.INSERT_CALLOUT_COMMAND = INSERT_CALLOUT_COMMAND;
exports.INSERT_CODE_BLOCK_COMMAND = INSERT_CODE_BLOCK_COMMAND;
exports.INSERT_EMAIL_COMMAND = INSERT_EMAIL_COMMAND;
exports.INSERT_EMBED_COMMAND = INSERT_EMBED_COMMAND;
exports.INSERT_FILE_COMMAND = INSERT_FILE_COMMAND;
exports.INSERT_HORIZONTAL_RULE_COMMAND = INSERT_HORIZONTAL_RULE_COMMAND;
exports.INSERT_HTML_COMMAND = INSERT_HTML_COMMAND;
exports.INSERT_IMAGE_COMMAND = INSERT_IMAGE_COMMAND;
exports.INSERT_MARKDOWN_COMMAND = INSERT_MARKDOWN_COMMAND;
exports.INSERT_PAYWALL_COMMAND = INSERT_PAYWALL_COMMAND;
exports.INSERT_PRODUCT_COMMAND = INSERT_PRODUCT_COMMAND;
exports.INSERT_TOGGLE_COMMAND = INSERT_TOGGLE_COMMAND;
exports.INSERT_VIDEO_COMMAND = INSERT_VIDEO_COMMAND;
exports.ImageNode = ImageNode;
exports.ImageParser = ImageParser;
exports.KoenigDecoratorNode = KoenigDecoratorNode;
exports.MarkdownNode = MarkdownNode;
exports.PaywallNode = PaywallNode;
exports.ProductNode = ProductNode;
exports.ToggleNode = ToggleNode;
exports.UPLOAD_IMAGE_COMMAND = UPLOAD_IMAGE_COMMAND;
exports.VideoNode = VideoNode;
exports.bytesToSize = bytesToSize;
//# sourceMappingURL=kg-default-nodes.js.map
